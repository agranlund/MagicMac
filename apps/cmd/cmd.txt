                                                  Hannover, den 22.06.90

BEDIENUNGSANLEITUNG ZUR GEMDOS (C) SHELL "CMD" und KAOS SHELL "KCMD" V2.59



Inhaltsverzeichnis
------------------

0. Allgemeines
1. Die internen Befehle
   1.1  ATTRIB
   1.2  BREAK
   1.3  CD
   1.4  CLS
   1.5  CK
   1.6  COPY
   1.7  DATE
   1.8  DEL
   1.9  DIR
   1.10 ECHO
   1.11 END
   1.12 EXIT
   1.13 FIND
   1.14 FOR
   1.15 FREE
   1.16 GOTO
   1.17 IF
   1.18 MD
   1.19 MORE
   1.20 MV
   1.21 PATH
   1.22 PAUSE
   1.23 PROMPT
   1.24 RD
   1.25 REN
   1.26 SHIFT
   1.27 SET
   1.28 SORT
   1.29 TIME
   1.30 TOUCH
   1.31 TREE
   1.32 TYPE
   1.33 VER
   1.34 VERIFY
2. Externe Kommandos im BIN- Ordner
   2.1  PRINT
   2.2  CRASHDMP
   2.3  EXE2BIN
   2.4  LABEL
   2.5  FC
   2.6  KILLRAM
   2.7  ASTOWORD
   2.8  WORDTOAS
   2.9  DUMP
   2.10 SPLIT
3. Stdout/Stdin- Umlenkung
4. Ger√§te (Devices)
5. Kommandozeilen- Auswertung
6. Editor- Steuertasten
7. Starten von Programmen (Externe Kommandos)
8. Batch- Dateien
9. CMD als Accessory. Allgemeines und spezielles


0. Allgemeines
--------------


Updates von V2.55 => V2.56:
- Korrektur des Befehls "COPY datei nul", der bisher bei mehr als 64k 
  Dateil√§nge nicht funktionierte.
- Korrektur der Datumsverarbeitung f√ºr Jahreszahlen nach dem Jahr 2000.
- Anpassung von KCMD.ACC an das endg√ºltige TOS 1.4 vom 6.4.89
- Korrektur einer Unsch√∂nheit beim Kopieren von Dateien. Wegen ungerader 
  Gr√∂√üe des Kopierpuffers konnte es vorkommen, da√ü das Kopieren 
  unertr√§glich langsam wurde, da Sektoren auf ungerade Adressen √ºbertragen 
  werden mu√üten.

Updates von V2.56 => V2.57:
- Wenn \AUTOEXEC.BAT bzw. \BOOT.BAT nicht gefunden werden k√∂nnen, wird 
  C:\AUTOEXEC.BAT  gesucht.  Wer  ein  anderes  Laufwerk  bevorzugt,  m√∂ge 
  einfach mit MUTIL suchen, sehen und patchen.
- Bei MORE wird der Tastendruck nicht mehr von BIOS, sondern von GEMDOS 
  geholt; daher kann man w√§hrend der Ausgabe schon eine Taste dr√ºcken, die 
  dann in den GEMDOS- Tastaturpuffer kommt.
- Bei DEL,COPY,MV,ATTRIB wird nach jeder Datei der GEMDOS- Tastaturpuffer 
  abgefragt, so da√ü man zwischendurch mit ^S anhalten, mit ^Q weiterlaufen 
  lassen und mit ^C abbrechen kann (zumindest unter KAOS).
- Bei DEL wird ein Schalter "-N" ausgewertet, mit dem man die 
  Sicherheitsabfrage abschalten kann.
- Bei KCMD setzt der Sconfig- Aufruf nicht mehr die Konfiguration  einfach 
  auf 1 (alle Bits au√üer automatischer Pfadsuche auf 0),  sondern holt die 
  aktuelle  Konfiguration,  setzt Bit 0 ohne Ver√§nderung der anderen  Bits 
  und setzt dann diese Konfiguration.

Updates von V2.57 => V2.58:
- Bei  "more" kann man mit der Leertaste ein Seite weiter und  sonst  eine 
  Zeile weiter scrollen.
- ACCs werden im Grafikmodus gestartet.

Updates von V2.58 => V2.59:
- Es wird zuerst nach C:\AUTOEXEC.BAT, dann nach \AUTOEXEC.BAT gesucht.
- Der  Event-Critic-Manager wurde an KAOS 1.4 angepa√üt und bricht  mit  ^C 
  das laufende Programm ab.
- F√ºr Turbo-C 2.0 wird der Befehl "sh" in der Kommandozeile ignoriert.
- neues externes Kommando: SPLIT
- √ºberarbeitet: DUMP


CMD  V2.59 samt Ordner BIN\ ist Shareware,  der Sharewarebeitrag  ist  bei 
regelm√§√üiger Benutzung zu entrichten und betr√§gt 20 DM (direkt per  Scheck 
oder Schein an den Autor), der Autor

  Andreas Kromke
  3000 Hannover 61
  Steinbruchstra√üe 17

verlangt  aber,  da√ü der Ordner KCMD immer als Ganzes  weiterzugeben  wird 
und  dieser  oder Teile davon nicht in irgendwelche  Softwarepakete  inte-
griert werden.  Eine gedruckte Anleitung oder ein Update- Service ist  bei 
einem  so geringen Beitrag nat√ºrlich nicht m√∂glich.  Kommerzielle  Nutzung 
(Vertrieb,  Beigabe  zu kommerziell  vertriebenen  Programmen,  Weitergabe 
gegen  Geb√ºhren etc.  in jeder Form (dies schlie√üt auch den Vertrieb  √ºber 
Public-Domain-Sammeldisketten oder √§hnliches ein) ist √ºnicht gestattet.
Die  Dateien d√ºrfen nicht von anderen gegen Bezahlung  weitergegeben  oder 
das  Programm  selbst  oder die  zugeh√∂rigen  Dateien  durch  unsachgem√§√üe 
Eingriffe ver√§ndert werden.
Daher merke:

     Wer Kommandoprozessoren nachmacht oder verf√§lscht oder 
     nachgemachte oder verf√§lschte Kommandoprozessoren sich 
     verschafft und in Verkehr bringt, wird mit Analysis- 
     Zetteln nicht unter 2 St√ºck bestraft

F√ºr  Sch√§den,  die durch Anwendung dieses Programms  entstehen,  kann  der 
Autor selbstverst√§ndlich nicht haften.
Eventuelle  √©hnlichkeiten  von CMD oder den  Hilfsprogrammen  mit  anderen 
Programmen namhafter oder unbekannter Hersteller sind nicht  beabsichtigt, 
sondern w√§ren rein zuf√§llig.

Das Betriebssystem GEMDOS des Atari ist,  einschlie√ülich der Funktionsnum-
mern f√ºr die DOS- Aufrufe, fast kompatibel zu MS-DOS 2.0. Auch lassen sich 
MS-DOS Disketten problemlos lesen und beschreiben.
Diese  √©hnlichkeit  hat mich bereits 1986  dazu  bewogen,  eine  Kommando- 
Oberfl√§che  wie COMMAND.COM f√ºr den Atari zu schreiben,  ohne  mich  dabei 
sklavisch an das "gro√üe" Vorbild zu halten.  Wer MS-DOS kennt,  wird  sehr 
schnell mit CMD umgehen k√∂nnen.  Man k√∂nnte dabei fast vergessen,  da√ü man 
es  mit einem Atari zu hat;  ja,  wenn nicht die vielen Fehler des  GEMDOS 
(oder  JAM-DOS ?) w√§ren;  nicht umsonst hei√üt die Version ja auch bei  TOS 
1.2  noch  0.19 und bei TOS 1.4 0.21 (siehe internes  Kommando  VER),  was 
auch kein gro√ües Vertrauen einfl√∂√üen kann.
Daher enth√§lt diese Diskette drei Versionen des CMD:

1)   CMD.PRG   geht sehr nachsichtig mit dem Betriebssystem um und  korri-
               giert einige DOS - Fehler wie die Diskwechselerkennung, das 
               Setzen der Uhrzeit von Dateien und einen Fehler beim Setzen 
               der  Standardpfade.  Die Fehler  der  Ein-/Ausgabeumlenkung 
               werden  NICHT umgangen;  CMD selbst funktioniert  aber  bei 
               Umlenkung.
               Die Haupteigenschaft ist der vom Betriebssystem unabh√§ngige 
               Zeileneditor,  der  in seinen Funktionen des in KAOS  1.2.3 
               integrierten Editors enspricht.
               CMD  l√§uft  auf  s√§mtlichen  alten  und  zuk√ºnftigen   TOS- 
               Versionen,  da  es v√∂llig  betriebssystemversionsunabh√§ngig 
               ist (langes Wort...).
2)   KCMD.PRG  f√ºr  das KAOS- Betriebssystem mit DOS- Versionsnummer  0.21 
               oder h√∂her.  Einige Features sind nur bei KCMD,  nicht  bei 
               CMD  vorhanden.  Auch  KCMD l√§uft "im  Prinzip"  mit  jedem 
               Betriebssystem; es enth√§lt jedoch keine Umgehungen von DOS- 
               Fehlern,  da dies bei KAOS nicht mehr n√∂tig ist.  So d√ºrfte 
               KCMD  besonders  auf den bisherigen TOS -  Versionen  nicht 
               immer perfekt funktionieren.
               Die  Hauptbesonderheit ist,  da√ü KCMD  keinen  integrierten 
               Zeileneditor besitzt,  sondern den vom DOS  verwendet.  Auf 
               dem normalen TOS ist KCMD also nicht besonders komfortabel.
               Alle  KCMD und KAOS betreffenden Stellen  dieser  Anleitung 
               sind hell markiert.
3)   KCMD.ACC  Die  Accessory- Version von KCMD.PRG.  Gegen√ºber  der  Pro-
               gramm-  Version m√ºssen nat√ºrlich einige Einschr√§nkungen  in 
               Kauf genommen werden.  So k√∂nnen beispielsweise keine  GEM- 
               Applikationen  gestartet  werden  (GfA-  BASIC  funktiniert 
               aber). Ansonsten mit KCMD im wesentlichen identisch. Alles, 
               was f√ºr die Accessory- Version und nicht f√ºr KCMD.PRG gilt, 
               ist hier kursiv hervorgehoben.

Ansonsten  sind   CMD.PRG,   KCMD.PRG  und  KCMD.ACC  unabh√§ngig  von  der 
Betriebssystem- Version und laufen daher mit s√§mtlichen bekannten  Versio-
nen des TOS (1.0 / 1.2 / 1.4).

Achtung:   Aufgrund  eines Fehlers im AES ist das Starten  von  Programmen 
           unter KCMD.ACC nur unter folgenden TOS- Versionen m√∂glich:
  TOS 1.0 vom 6.2.86
  TOS 1.2 vom 22.4.87
  TOS 1.4 vom 6.4.89
Bei  diesen Versionen wurde der Fehler umgangen,  leider mu√üte dabei  eine 
Versions-  Abh√§ngigkeit in Kauf genommen werden.  N√§heres steht  in  Kapi-
tel 9.

Noch ein Hinweis zu GEMDOS- Fehlern:

Angeblich  existiert eine Liste mit 96 Fehlern,  was nicht  genau  stimmen 
mu√ü, aber durchaus glaubw√ºrdig erscheint. Fast alle diese Fehler treten im 
Desktop  nicht  auf,  werden daher von 99% aller Atari-  Besitzer  niemals 
bemerkt werden.  Unter CMD, das sich ausschlie√ülich auf GEMDOS verl√§√üt und 
keinen seiner Fehler abf√§ngt,  sieht das ganz anders aus.  St√§ndig  treten 
neue, unbekannte Fehlfunktionen auf.

Ein Fehler ist dabei eigentlich alles, was bei MS-DOS 2.0 funktioniert und 
bei GEMDOS nicht.  Meistens sagt einem aber auch der gesunde  Menschenver-
stand, ob etwas so sein sollte oder nicht.

Ein besonders √§rgerlicher Fehler ist z.B. :

  Verwendet  man Pfadnamen wie "A:CMD.PRG" anstelle  von  "A:\....",  also 
  verwendet  den aktuellen Pfad eines Laufwerks,  kann es vorkommen  (auch 
  unter  TOS 1.4 und auf dem TT !!!!),  da√ü GEMDOS mit seinen  Pfaden  und 
  Laufwerken v√∂llig durcheinanderkommt.  Z.B.  kann bei "DIR A:" der Disk-
  name von A:  und dann das Verzeichnis von D:  erscheinen. Der Disketten-
  name stimmt immer,  da er immer vom Wurzelverzeichnis geholt  wird,  was 
  keine Schwierigkeiten macht.

  Abhilfe: Erscheint z.B.  bei "DIR D:" das Verzeichnis von A:,  gen√ºgt es 
           meistens,  "CD  D:\"  und "CD A:\" einzugeben.  Dann  hat  sich 
           GEMDOS   wieder   beruhigt,   vielleicht   bis   zum   n√§chsten 
           Diskwechsel.
           Der  Fehler  tritt gar nicht auf,  wenn  man  alle  Pfadangaben 
           immer auf der Root beginnt.  Also "DIR A:\" geht (fast)  immer. 
           Aus  diesem  Grund hat auch das  Desktop  keine  Probleme,  das 
           sowieso die meisten Fehler des GEMDOS abf√§ngt.

Alle  diese Fehler sind unter KAOS behoben und d√ºrfen bei KAOS+KCMD  nicht 
auftreten.  KCMD schaltet per Sconfig(1,1L) die automatische  Pfad√ºberpr√º-
fung  ein  (siehe Beschreibung von KAOS) und stellt vor  Programmende  den 
vorherigen Zustand wieder her.

Wurde CMD mit Kommandozeile gestartet,  wird diese ausgef√ºhrt. Andernfalls 
wird,  falls vorhanden,  eine Batchdatei "\AUTOEXEC.BAT" ausgef√ºhrt  (d.h. 
auf  dem Wurzelverzeichnis des aktuellen Laufwerks);  wurde CMD  im  AUTO- 
Ordner  oder mit der comload- Option gestartet,  wird  statt  AUTOEXEC.BAT 
eine Batchdatei mit Namen BOOT.BAT ausgef√ºhrt.  Schl√§gt der erste  Versuch 
fehl,  wird  nach  C:\AUTOEXEC.BAT gesucht (auch im  Fall  AUTO-  Ordner). 
Danach wird immer der freie Speicher angezeigt.
Wird beim Laden die Taste CTRL-C gedr√ºckt, unterbleiben obige Aktivit√§ten.
Ein Tip:  Im  Desktop unter "EXTRAS:  Anwendung anmelden" f√ºr CMD.PRG  als 
          Dateityp ".BAT" anmelden.  Wenn man eine Festplatte benutzt, das 
          DESKTOP.INF  in  einen  geeigneten Editor laden  und  statt  nur 
          "CMD.PRG" den Pfad, auf dem sich CMD befindet, mit angeben, z.B. 
          "C:\CMD.PRG".
          Dann  kann  jede  Batchdatei mit Doppelklick  wie  ein  Programm 
          gestartet  werden.  Enth√§lt die Batchdatei einen  EXIT-  Befehl, 
          wird nach Ablauf des Batchprogramms wieder ins Desktop zur√ºckge-
          kehrt;  man kann auch vor EXIT einen PAUSE- Befehl einf√ºgen, der 
          erst auf einen Tastendruck wartet.
          F√ºr  TOS 1.0 und 1.2 beachte man,  da√ü ein Doppelklick auf  eine 
          Datei .BAT folgendes bewirkt:
           -   Das Verzeichnis, in dem die Datei (!) liegt, wird aktuelles 
               Verzeichnis.
           -   pfad\CMD wird mit dem einfachen Dateinamen ohne  Pfadangabe 
               gestartet.
          In TOS 1.4 (8.8.88) gilt:
           -   Das  Verzeichnis,  in  dem CMD (!)  liegt,  wird  aktuelles    
               Verzeichnis.
           -   CMD wird in seinem eigenen (aktuellen) Verzeichnis  gestar-
               tet und erh√§lt als Parameter den vollst√§ndigen (!)  Pfadna-
               men  der Datei.  Falls sich CMD und .BAT im  selben  Ordner 
               befinden,  verzichtet AES auf den Pfad der Datei,  aber das 
               hat keinen Einflu√ü auf die Wirkungsweise.

CMD  enth√§lt keine GEM- Aufrufe,  kann also im AUTO- Ordner oder  mit  der 
comload- Option des Bootprogramms geladen werden. In diesem Fall kann aber 
nat√ºrlich  kein  GEM-  Programm von CMD  aus  gestartet  werden.  Ist  das 
aufgerufene GEM- Programm ordentlich geschrieben (leider selten der Fall), 
so  wird  es  einfach mit  oder  ohne  Fehlermeldung  abbrechen.  Au√üerdem 
funktioniert  das  Einschalten des Mauszeigers nicht,  wenn CMD  im  AUTO- 
Ordner  stand,  da die zugeh√∂rigen LineA- Funktionen zu  diesem  Zeitpunkt 
noch nicht initialisiert sind.
Wurde CMD mit der comload - Option gestartet,  ist es nicht zu  empfehlen, 
das Kommando "exit" einzugeben, da dies zum Systemabsturz f√ºhrt. Atari hat 
diesen Fall offensichtlich nicht ber√ºcksichtigt.
Wurde  CMD im AUTO- Ordner gestartet,  sollte man die Diskette auf  keinen 
Fall wechseln,  damit der AUTO- Vorgang nach Beendigung von CMD weiterlau-
fen kann.  Mu√ü die Diskette doch gewechselt werden,  mu√ü man unbedingt vor 
dem  "exit"-  Kommando die AUTO- Diskette wieder einlegen  und  "cd  auto" 
eingeben (um den Ordner GEMDOS bekanntzumachen).

KCMD.ACC wertet niemals eine Kommandozeile aus,  sondern l√§dt AUTOEXEC.BAT 
beim ersten Anw√§hlen des Accessories. Aktiviert man sp√§ter noch einmal das 
Accessory, wird sofort das erste Kommando von der Tastatur erwartet.

KCMD.ACC enth√§lt nat√ºrlich GEM- Aufrufe zum Anmelden im Men√º.  Accessories 
werden  immmer erst nach dem Start von AES geladen.  Daher gibt  es  keine 
Sonderregelungen f√ºr den Start aus dem AUTO- Ordner etc.
Man kann f√ºr das Accessory keinen Dateityp anmelden.

In CMD wird bei jedem Dateizugriff interner Kommandos festgestellt,  ob im 
angesprochenen  Laufwerk  die Diskette gewechselt  wurde.  Wenn  ja,  wird 
GEMDOS  durch  den Aufruf von Fsfirst()  dazu  veranla√üt,  seine  internen 
Pfadpuffer zu aktualisieren.  Daher ist darauf zu achten,  da√ü  z.B.  beim 
Wechsel des aktuellen Laufwerks schon eine Diskette eingelegt ist.
¬∏Da  besagter  Fsfirst() - Aufruf mit dem Wurzelverzeichnis  als  Pfad  der 
einzige  (!) GEMDOS - Befehl ist,  der den Diskettenwechsel abfragt  (auch 
ein Programmierfehler!),  gibt es sonst Schwierigkeiten mit dem  Auffinden 
von Pfaden und Dateien z.B.  bei COPY und CD.
Die Schwierigkeiten bleiben jedoch bei externen Befehlen:
Hat man z.B.  in A:  eine neue Disk eingelegt und ruft auf D: ein externes 
Programm  mit  "D>pgm a:\subdir\dat"  auf,  wird GEMDOS  die  Datei  "dat" 
(sofern  das externe Programm seinen Parameter durch Fopen()  sucht)  i.a. 
nicht  finden k√∂nnen,  bevor es nicht durch einen Fsfirst()-  Aufruf  dazu 
veranla√üt wurde, seine internen Pfadpuffer neu aufzubauen.
Abhilfe:  Nach jedem Diskwechsel in X:  erst mit "X:" oder "dir X:" GEMDOS 
initialisieren, bevor man ein Programm startet.
√áUnter  KAOS  und KCMD tritt der Fehler nicht auf,  da  per  Sconfig()  die 
automatische  Pfad√ºberpr√ºfung eingestellt wurde.  Weder bei internen  noch 
bei externen Kommandos d√ºrfte es zu Schwierigkeiten kommen.  Damit hat man 
mit  KCMD und KAOS dieselbe Zuverl√§ssigkeit wie unter COMMAND.COM und  MS-
DOS;  mit dem Unterschied,  da√ü bei nicht schreibgesch√ºtzten Disketten der 
Pfadzugriff  sehr viel schneller verl√§uft,  da MS-DOS die Pfade  nicht  im 
Speicher h√§lt.


1. Die internen Befehle
-----------------------


1.1 ATTRIB
----------

Syntax: ATTRIB [schalter1 schalter2 ...] name1 name2 ...
               schalter = +|-{rsha}
               name     = Dateiname oder -muster oder Pfad
Zweck:  Attributbyte von Dateien anzeigen oder √§ndern.
Werden keine Schalter angegeben, werden die Attribute nur angezeigt:
  R Read-Only                 (schreibgesch√ºtzt)
  S System                    (versteckte Systemdatei)
  H Hidden                    (versteckte Datei)
  A Archive                   (erst ab TOS 1.4 unterst√ºtzt)
Mit  "ATTRIB  +r c:  f:" lassen sich beispielsweise alle  Dateien  in  den 
aktuellen Verzeichnissen der Laufwerke C: und F: schreibsch√ºtzen.
"ATTRIB -rsha d:\cmd.prg"  l√∂scht alle obigen Attribute der Datei  cmd.prg 
im Wurzelverzeichnis von D:.
Ab  TOS 1.4 wird das Attribut 'A' korrekt ausgewertet,  ansonsten  erf√ºllt 
kein   einziges  der  Attribute  bei  irgendeinem  von  Atari   stammenden
Betriebssystem   den   urspr√ºnglich  dokumentierten   Zweck!   Das   hei√üt 
beispielsweise,  da√ü  man schreibgesch√ºtzte Dateien unter TOS  munter  be-
schreiben kann.
Disknamen und Ordner werden nicht angezeigt oder ver√§ndert!

1.2 BREAK
---------

Syntax: BREAK
        BREAK ON
        BREAK OFF
Zweck:  Break-  Verify-  Flag des  KAOS  anzeigen/√§ndern.  Unter  normalem 
        GEMDOS bewirkt der Befehl einfach nichts.
Beim  Starten  von  CMD  ist das  Break-  Flag  immer  ausgeschaltet.  Bei 
eingeschaltetem  Flag kann man ein laufendes Programm vor und  nach  jedem 
GEMDOS- Aufruf abbrechen.
Im  Gegensatz  zu MS-DOS bewirkt das Bet√§tigen von CTRL-C  im  TOS  leider 
keinen  Interrupt in eine Break-Handling-Routine.  Daher funktioniert  die 
Bet√§tigung  von CTRL-C wirklich nur bei Eintritt und Austritt aus  GEMDOS, 
wo  der  Tastaturpuffer  durchsucht und  bei  Bedarf  ein  Programmabbruch 
bewirkt wird.

1.3 CD
------

Syntax: CD
        CD d:
        CD pfad
        CD d:pfad
Zweck:  Aktuelles Verzeichnis anzeigen oder √§ndern
CD  (change directory) ohne Parameter zeigt das aktuelle  Verzeichnis  des 
aktuellen Laufwerks.
CD d: zeigt das aktuelle Verzeichnis des Laufwerks d:.
CD pfad setzt <pfad> als aktuelles Verzeichnis des aktuellen Laufwerks.
CD d:pfad setzt <pfad> als aktuelles Verzeichnis des Laufwerks  d:.  Diese 
Befehlsform  mit  d:  als  einem  nicht  aktuellen  Laufwerk  ist,  obwohl 
dokumentiert,  bei  den von Atari stammenden TOS- Versionen nicht  m√∂glich 
und funktioniert nur unter KAOS.

1.4 CLS
-------

Syntax: CLS
Zweck:  Bildschirm l√∂schen. Au√üerdem WRAP ON und INVERS OFF.

1.5 CK
------

Syntax: CK
        CK d:
Zweck:  Laufwerk- Informationen ausgeben
CK (checkdisk) gibt die Laufwerks- Informationen f√ºr das Laufwerk d:  aus. 
Wurde kein Parameter angegeben, wird das aktuelle Laufwerk benutzt.
Au√üerdem  wird die Gr√∂√üe des Hauptspeichers angezeigt.  CMD  verl√§√üt  sich 
dabei auf die Systemvariable phystop;  ist diese Variable z.B.  von  einer 
resetfesten  Ramdisk manipuliert worden,  kann der  tats√§chliche  Speicher 
gr√∂√üer sein, als von CK angezeigt.

1.6 COPY
--------

Syntax: COPY [-t] pfad
        COPY [-t] datei(muster)
        COPY [-t] pfad pfad
        COPY [-t] datei(muster) pfad
        COPY [-t] datei1 datei2

Zweck:  Datei(en) kopieren

Fehlt der zweite Parameter, wird das aktuelle Verzeichnis angenommen.
Ist  die  Quelle ein Pfad oder ein Dateimuster,  werden alle  Dateien  des 
Pfades bzw. alle passenden Dateien kopiert.

Ein Pfad kann auf '\' enden oder auch nicht.

Wird <datei2> angegeben, bekommt die Kopie der Datei den Namen <datei2>.
Quelle  und Ziel k√∂nnen auch Ger√§te ("CON:","AUX:","PRN:") sein.  Ist  die 
Quelle ein Ger√§t (CON:,AUX:),  wird kopiert,  bis eine Zeile gelesen wird, 
die  nur  aus  CTRL-Z besteht.  Nach jeder  eingelesenen  Zeile  wird  die 
Zeichenfolge CR/LF erg√§nzt.

Eine  Datei  kann nicht in sich selbst kopiert werden;  CMD  f√§ngt  diesen 
Fehler geschickt ab.√á KAOS tut dies selbst.

Sind weniger als 10kB Speicher frei,  wird der gesamte freie Speicher  als 
Kopierpuffer benutzt,  sonst wird nur die H√§lfte verwendet.  So kann  sich 
(im  Gegensatz  zum  Desktop  ab TOS 1.2)  eine  dynamische  Ramdisk  noch 
vergr√∂√üern.

Im Gegensatz zum Desktop-COPY beim ungepatchten TOS behalten Dateien  beim 
Kopieren  ihr  altes  Datum und die Uhrzeit (nicht  bei  ungepatchtem  TOS 
1.0/1.2 und KCMD.PRG,  da KCMD den DOS- Fehler nicht abf√§ngt).  Jedoch ist 
das Dateiattribut immer 0 (normale Datei, nicht schreibgesch√ºtzt, sichtbar 
usw.).

Mit  Hilfe des Schalters 'T' bekommt die Zieldatei  das  Tagesdatum,  also 
entspricht "COPY -t ..." dem √ºblichen Desktop- COPY.  Dieser Schalter  ist 
zu empfehlen,  wenn man z.B.  Dateien mit dem nichtssagenden Datum  6.2.86 
oder 22.4.87 kopiert.  'T' ist die Abk√ºrzung f√ºr "Touch" und bedeutet, da√ü 
eine  Datei  das Tagesdatum bekommt,  wie wenn sie  ge√§ndert  worden  w√§re 
(siehe auch internes Kommando "TOUCH"). Wichtig ist das z.B., wenn man ein 
MAKE benutzt.

Bemerkung: In MS-DOS existiert eine Befehlsform zum Verketten von  Dateien 
           ("COPY  datei1+datei2+...  zieldatei).  CMD verwendet dazu  den 
           TYPE- Befehl (s.u.).
           F√ºr das Erstellen von Batchdateien eignet sich der Befehl "COPY 
           CON:  datei".  Die Eingabe wird mit einer Zeile  abgeschlossen, 
           die nur aus CTRL-Z besteht.

           F√ºr das Testen,  ob eine Datei einen Lesefehler enth√§lt, eignet 
           sich  besonders  der  Befehl "COPY  datei  nul".  Hierbei  wird 
           besonders schnell gelesen, da nichts geschrieben werden mu√ü.

1.7 DATE
--------

Syntax: DATE
        DATE datumsangabe
Zweck:  Systemdatum setzen
Wird  DATE ohne Parameter gestartet,  kann das Datum von  Hand  eingegeben 
werden.  Wird nur <Return> gedr√ºckt, bleibt die alte Einstellung erhalten. 
Wird nur eine Zahl eingegeben,  wird nur der Tag ge√§ndert, bei zwei Zahlen 
Tag und Monat.  Tag,  Monat,  Jahr k√∂nnen durch beliebige  nichtnumerische 
Zeichen voneinander getrennt werden.
Bemerkung: Mit  "DATE  <datei"  kann das Datum  statt  von  der  Standard- 
           Eingabe auch von einer Datei gelesen werden.
           Bei TOS 1.0 wird nur die GEMDOS- Uhr gesetzt,  so da√ü die  alte 
           Zeit  im  Tastaturprozessor (XBIOS- Aufruf) und  so  bei  einem 
           Reset  erhalten  bleibt.  Ab  TOS 1.2 wird  die  Hardware-  Uhr 
           (Quarzuhr bzw. Tastaturprozessor) mitgesetzt.

1.8 DEL
-------

Syntax: DEL [-n] datei1 datei2 ...
Zweck:  Datei(en) l√∂schen
DEL (delete) kann beliebig viele Argumente haben (OS/2 l√§√üt  gr√º√üen).  Ist 
<datei> ein Dateimuster oder ein Pfad,  werden alle passenden Dateien nach 
Sicherheitsabfragen gel√∂scht; diese Sicherheitsabfrage kann mit dem 
Schalter "-N" abgeschaltet werden.
Auf die Sicherheitsabfragen kann geantwortet werden:
J,Y       Ja, angezeigte Datei l√∂schen; weiterfragen
N         Nein, angezeigte Datei nicht l√∂schen; weiterfragen
G         Global, ab jetzt alle Dateien ohne Abfragen l√∂schen
A,Q,^C    Abbruch, L√∂schen beenden
Wenn  ein  Fehler auftritt,  mu√ü dies nicht daran liegen,  da√ü  die  Datei 
schreibgesch√ºtzt ist.  Ein Fehler tritt auch dann auf,  wenn die Datei von 
CMD  oder  einem  anderen Vorg√§ngerproze√ü ge√∂ffnet wurde  und  noch  nicht 
geschlossen  ist.  In  solch einem Fall gen√ºgt es,  die Diskette  mit  dem 
Kommando "free" (s.u.) abzumelden.

1.9 DIR
-------

Syntax: DIR pfad1 pfad2 ...
        DIR -W -P -Q -S ...
        DIR -WQP pfad
        DIR -P pfad1 -W pfad2 -W -D pfad3 ...
Zweck:  Inhaltsverzeichnis anzeigen

-W gibt ein "platzsparendes" Listing aus          (wide).
-P h√§lt das Listing nach jeder Seite an           (page).
-Q verzichtet auf Diskname und freien Speicher    (quick).
-S listet alle Dateien mit Attributen             (system).

Sortiermodi:
-N ordne Namen
-D ordne Datum/Zeit
-G ordne Gr√∂√üe
-A ordne Art
-U unsortiert

Beim Sortieren (wenn nicht Option -U aktiv ist) werden Ordner immer zuerst 
angezeigt.  Wird  kein Sortiermodus angegeben,  wird der des letzten  DIR- 
Aufrufs  benutzt;  bei  Fehleingaben wird nach  Namen  sortiert.  Bei  der 
Ausgabe eines Verzeichnis wird der Sortiermodus mit ausgegeben, wenn √ºnicht 
nach Namen sortiert wird.

DIR kann maximal 512 Eintr√§ge sortieren und ben√∂tigt dazu kurzfristig etwa 
14k Hautpspeicher.  Ist nicht gen√ºgend freier Speicher vorhanden, wird das 
Verzeichnis  unsortiert  ausgegeben.  Dies ist besonders  f√ºr  Accessories 
wichtig,  WORDPLUS l√§√üt immer nur etwa 4k frei, andere Programme sind noch 
schlimmer.

DIR  kann beliebig viele Argumente haben,  die Verzeichnisse  werden  dann 
nacheinander  ausgegeben.  Dabei  wird  die Anzahl  der  Dateien  und  die 
Dateil√§ngen  insgesamt addiert und erst ganz zum  Schlu√ü  ausgegeben.  Die 
freien  Bytes  der Disk werden nicht  ausgegeben.  Diese  M√∂glichkeit  ist 
praktisch,  wenn man die Gesamtl√§nge bestimmter Dateien ermitteln  m√∂chte, 
die auf verschiedenen Pfaden liegen, um sie auf eine Disk zu kopieren, auf 
der wom√∂glich nicht mehr gen√ºgend Platz ist.

Ist  <pfad> ein Dateimuster (z.B.  "texte\*.doc"),  werden alle  passenden 
Dateien ausgegeben.

Wenn  der  Schalter  "s"  nicht  angegeben  wurde,  werden  nur  "normale" 
Dateien angezeigt.  Mit "s" werden auch Systemdateien oder versteckte  (!) 
Dateien angezeigt, Dateien mit Attribut "Volume" jedoch nie.

Man beachte,  da√ü beim ungepatchten GEMDOS  z.B.  schreibgesch√ºtzte,  ver-
steckte Dateien oder versteckte Disknamen wieder sichtbar  werden.  Dieser 
Fehler  ist auch in TOS 1.4 noch enthalten,  aber die Dokumentation  wurde 
dem Fehler angepa√üt ("It's a feature, not a bug").

Der  Schalter  "q" ist f√ºr TOS vor 1.4 und Festplatten  gedacht,  die  mit 
kleinen  Clustern  (1 kB) formatiert sind und daher eine  besonders  gro√üe 
FAT haben. Die Ausgabe erfolgt dann sehr viel schneller.

1.10 ECHO
---------

Syntax: ECHO
        ECHO [-n] string1 string2 ...
        ECHO ON
        ECHO OFF
Zweck:  Zeichenketten ausgeben oder ECHO- Modus setzen/anzeigen
ECHO  ohne Parameter zeigt den ECHO- Modus f√ºr den  Batchbetrieb  an.  Per 
Default  ist  ECHO  immer OFF (d.h.  die  ausgef√ºhrten  Zeilen  werden  im 
Batchbetrieb √ºnicht angezeigt).
ECHO ON oder ECHO OFF setzt den ECHO- Modus.
ECHO <string> gibt <string> und dann einen Zeilenvorschub nach stdout aus, 
mit der Option -n wird dieser Zeilenvorschub unterdr√ºckt.

1.11 END
--------

Syntax: END
Zweck:  Bricht Batchdatei ab
END  bricht nur die laufende Batchdatei ab;  wenn diese von einer  anderen 
Batchdatei  aufgerufen  wurde,  wird  die n√§chste  Zeile  wieder  aus  der 
√ºbergeordneten Batchdatei geholt.

1.12 EXIT
---------

Syntax: EXIT
Zweck:  cmd verlassen
Im  Gegensatz  zu COMMAND.COM in MS-DOS bewirkt auch im  Batchbetrieb  der 
Befehl EXIT ein Verlassen des Kommandointerpreters.

1.13 FIND
---------

Syntax: FIND string
Zweck:  Zeichenketten in Textdateien suchen
FIND  ist  ein Filter,  das hei√üt,  er liest von stdin und  schreibt  nach 
stdout. Man mu√ü also stdin auf die zu durchsuchende Datei umlenken.
FIND unterscheidet nicht zwischen Gro√ü- und Kleinschreibung.
Bemerkung: Falls <string> Leerstellen enth√§lt, mu√ü <string> in Anf√ºhrungs-
           zeichen gesetzt werden.
           CTRL-Z wird als Dateiende erkannt

1.14 FOR
--------

Syntax: FOR var ( wert1 wert2 .. ) ...
  Setzt var=wert1, f√ºhrt ... aus. Beim n√§chstenmal wird var=wert2 gesetzt
  und ... ausgef√ºhrt usw. Ist die Liste zuende, d.h. ')' erreicht, wird
  ... nicht ausgef√ºhrt, sondern gleich zum n√§chsten Kommando √ºbergegangen.
        FOR NOT var ( wert1 wert2 .. ) ...
  Setzt var=wert1, √ºberspringt ... Beim n√§chstenmal wird var=wert2 gesetzt
  und ... wieder  √ºbersprungen  usw. Ist  die  Liste  zuende,   d.h.   ')' 
  erreicht, wird ... ausgef√ºhrt.
Zweck:  Steuerung in Batch- Dateien
FOR darf nicht geschachtelt werden!!!
Die Leerzeichen vor und nach den Klammern sind notwendig!!!

1.15 FREE
---------

Syntax: FREE [x:]
Zweck:  Gibt GEMDOS- Speicher f√ºr aktuelles oder Laufwerk x: frei.
Wenn  das  100 Ordner Problem akut wird,  kann man mit diesem  Befehl  den 
Speicher  f√ºr eine gerade nicht ben√∂tigte Harddisk-  Partition  freigeben. 
Au√üerdem kann man diesen Befehl anwenden, wenn GEMDOS sich weigert, Ordner 
oder  Dateien zu l√∂schen,  obwohl diese leer bzw.  nicht  schreibgesch√ºtzt 
sind.

1.16 GOTO
---------

Syntax: GOTO label
Zweck:  Unbedingter Sprung in Batch- Dateien
Das Label in einer Batchdatei hat die Form ":name"

1.17 IF
-------

Syntax: IF ERRORLEVEL n ... F√ºhrt ... aus, wenn Fehlercode >= n oder < 0
        IF s1 == s2 ...     F√ºhrt ... aus, wenn <s1> = <s2>.
        IF EXIST datei ...  F√ºhrt ... aus, wenn <datei> existiert.
        IF NOT ...          F√ºhrt ... aus, wenn Bedingung nicht erf√ºllt
Zweck:  Bedingter Sprung in Batch- Datei.
Der  Fehlercode  wird  vom letzten  ausgef√ºhrten  internen  oder  externen 
Kommando zur√ºckgegeben.  Ein Wert ungleich Null signalisiert i.a.  da√ü ein 
Fehler aufgetreten ist.  Die Befehle IF,END,FOR,GOTO ver√§ndern den Fehler-
code nicht.

1.18 MD
-------

Syntax: MD datei
Zweck:  Neuen Ordner erstellen
MD  (make directory) erstellt einen neuen Ordner mit  Namen  <datei>.  Ein 
Ordner  oder  eine  Datei  gleichen Namens  darf  nicht  schon  im  selben 
Verzeichnis vorhanden sein.
Achtung:  Normale  Dateien oder Disknamen werden vor TOS 1.4  wegen  eines 
          GEMDOS- Fehlers durch MD gel√∂scht,  wenn sie denselben Namen wie 
          der neue Ordner haben. Alternative: KAOS benutzen.

1.19 MORE
---------

Syntax: MORE
Zweck:  Seitenweise Ausgabe von Texten
MORE ist ein Filter.  Wird "--Mehr--" angezeigt,  kann die Ausgabe mit  ^C 
abgebrochen werden.  Mit der Leertaste wird eine Seite,  sonst eine  Zeile 
weitergescrollt.
^Z in der Datei wird als Dateiende erkannt.
MORE  sollte wie alle Filter nur in Pipes oder bei  umgelenkter  Standard- 
Eingabe angewendet werden,  da sonst von der Tastatur gelesen  wird;  z.B. 
wirkt  "MORE <datei" √§hnlich wie die Funktion "Datei anzeigen" im  Desktop 
(ohne  sich  jedoch  bei  leeren Dateien oder  solchen  mit  n*4096  Bytes 
oder Lesefehlern aufzuh√§ngen...)

1.20 MV
-------

Syntax: Siehe COPY
Zweck:  Datei(en) umbenennen oder verschieben
MV  (move)  wirkt √§hnlich wie COPY,  kopiert die Datei(en)  jedoch  nicht, 
sondern  verschiebt  sie innerhalb der Verzeichnis- Struktur  eines  Lauf-
werks, was nat√ºrlich viel schneller geht. Beispiele:

- "MV datei neuername"        benennt die die <datei> einfach um.
- "MV . \"                    verschiebt alle Dateien im aktuellen  Unter-
                              verzeichnis  (".") in das  Wurzelverzeichnis 
                              ("\").
- "MV \*.h headers"           verschiebt alle C- Headerdateien vom Wurzel-
                              verzeichnis in den (hoffentlich vorhandenen) 
                              Ordner "headers".
- "MV auto\dat.prg"           Schiebt die Datei "dat.prg" vom AUTO- Ordner 
                              ins aktuelle Verzeichnis.

Das Verschieben ist immer nur auf demselben Laufwerk m√∂glich.  Die  Angabe 
von Ger√§ten (CON:,AUX:,PRN:) ist unzul√§ssig.  Ebenso darf keine Datei  mit 
dem neuen Namen schon existieren.
MV  gibt bei Fehlernummern den vom DOS erhaltenen Fehlercode  im  Klartext 
aus.√á  Leider hat dieser nur bei KAOS unmittelbar etwas mit dem tats√§chlich 
aufgetretenen Fehler zu tun.
Wenn  man nicht unter KAOS arbeitet,  ist der MV- Befehl mit  Vorsicht  zu 
genie√üen.   Schwierigkeiten  gibt  es  beispielsweise  bei  vollem   Root- 
Directory oder Umbenennen in ein existierendes Unterverzeichnis usw.
Bemerkung: Bei MS-DOS ist hier nur das Umbenennen EINER Datei in DEMSELBEN 
           VERZEICHNIS m√∂glich.  CMD bietet dagegen alle M√∂glichkeiten des 
           UNIX- Kommandos MV.
           Au√üerdem  hat  auch CMD den Befehl REN,  der wie  unter  MS-DOS 
           arbeitet und ab TOS 1.4 auch Ordner umbenennen kann.

1.21 PATH
---------

Syntax: PATH
        PATH pfad1;pfad2...
Zweck:  Kommando- Suchpfad setzen oder anzeigen
PATH  ohne  Parameter zeigt den Suchpfad an.  Mit  Parameter  wird  dieser 
gesetzt. Es wird nicht gepr√ºft, ob die Pfadangaben korrekt sind.
Bemerkung: Der Suchpfad ist eine Environment- Variable, kann also auch mit 
           SET manipuliert werden, z.B.
               SET %path%;pfad3
           h√§ngt <pfad3> an den Suchpfad an

1.22 PAUSE
----------

Syntax: PAUSE
        PAUSE string1 string2 ...
Zweck:  Unterbrechung und Verzweigung in Batch- Datei
PAUSE schreibt den <string> nach "CON:",  nicht nach stdout;  ebenso  wird 
IMMER von "CON:" (Tastatur) gelesen,  ohne R√ºcksicht auf die  Standardein-
gabe- Umlenkung.
Wird kein <string> angegeben, gibt PAUSE die Meldung "Taste dr√ºcken" aus.
Der  Ascii- Code der bet√§tigten Taste wird nach "errorlevel"  geschrieben. 
Mit  Hilfe  des  IF  ERRORLEVEL  - Befehls  kann  dann  abh√§ngig  von  der 
bet√§tigten Taste im Batchprogramm verzweigt werden.

1.23 PROMPT
-----------

Syntax: PROMPT
        PROMPT zeichenkette
Zweck:  Promptzeichen √§ndern
PROMPT  ohne Parameter setzt das Default- Prompt ("$n$g"),  mit  Parameter 
k√∂nnen au√üer den normalen Zeichen auch die bei MS-DOS √ºblichen  Sonderzei-
chen  verwendet  werden,  z.B.  "$p$g" f√ºr die  komplette  Pfadangabe  als 
Prompt oder auch "$ej$eH$eK$t$ek$n$g":

  $$    Das Dollarzeichen '$' selbst
  $_    Neue Zeile (CR,LF)
  $b    Das Zeichen '|'
  $d    Datum
  $e    Das Zeichen ESC (1BH)
  $g    Das Zeichen '>'
  $h    Backspace
  $l    Das Zeichen '<'
  $n    aktuelles Laufwerk
  $p    kompletter aktueller Pfad mit Laufwerk
  $q    Das Zeichen '='
  $t    Zeit

Bemerkung: Das Prompt ist eine Environment- Variable,  kann also auch  mit 
           SET manipuliert werden.
           Das  bei  MS-DOS  vorhandene Promptzeichen "$v"  f√ºr  die  DOS- 
           Version  fehlt bei CMD.  Als Ersatz siehe das interne  Kommando 
           "ver".

1.24 RD
-------

Syntax: RD ordnername
Zweck:  Verzeichnis l√∂schen
RD (remove directory) kann nur leere (!) Verzeichnisse l√∂schen.
Au√üer  bei KAOS bewirkt das L√∂schen des aktuellen (leeren)  Verzeichnisses 
Bomben oder Schlimmeres. Bei KAOS gibt es nur ein "Zugriff unm√∂glich". Man 
beachte, da√ü auch die aktuellen Verzeichnisse des Desktop gesch√ºtzt werden 
m√ºssen  und  nicht gel√∂scht werden sollten.  KAOS tut dies von  sich  aus; 
daher  kann  es vorkommen,  da√ü sich Ordner aus  "unerfindlichen"  Gr√ºnden 
nicht  l√∂schen  lassen.  In diesem Fall gen√ºgt ein  FREE  (s.o.),  um  das 
Laufwerk  auch  f√ºr  DESKTOP abzumelden;  dann  lassen  sich  alle  Ordner 
l√∂schen.
Bemerkung: Aufgrund  eines der vielen TOS- Fehler kann es  vorkommen,  da√ü 
           ein  gerade erstelltes Verzeichnis nicht gel√∂scht werden  kann. 
           Abhilfe :  IBM kaufen,  KAOS benutzen oder einfach  UNDO,RETURN 
           dr√ºcken.

1.25 REN
--------

Syntax: REN alter_pfadname neuer_dateiname
Zweck:  Eine Datei oder einen Ordner umbenennen
Der  Befehl  REN  entspricht v√∂llig seinem  Pendent  in  COMMAND.COM.  Der 
Parameter  <alter_pfadname>  enth√§lt Pfad und  Namen  der  umzubenennenden 
Datei, der Parameter <neuer_dateiname> enth√§lt den neuen Namen √ºohne Pfad.
Mit  diesem Befehl kann eine Datei im selben Verzeichnis  umbenannt,  also 
nicht  verschoben werden (siehe MV).  Au√üerdem wird immer nur  √ºeine  Datei 
behandelt, die Parameter d√ºrfen beide keine Wildcards ('?','*') enthalten.
√ºAb  TOS 1.4 k√∂nnen mit diesem Befehl auch Ordner  umbenannt  werden.  Dazu 
wird der Ordner wie eine Datei ohne abschlie√üendes '\' spezifiziert.
1. Beispiel:
  ren c:\compiler\turbo\tc.prg tc.ttp
ist √§quivalent zu
  mv  c:\compiler\turbo\tc.prg c:\compiler\turbo\tc.ttp
2. Beispiel (ab TOS 1.4):
  ren folder ordner
Benennt  √ºden Ordner "folder" in "ordner" um.  Ein √§quivalenter MV-  Befehl 
ist  nicht  m√∂glich,  da dieser alle Dateien aus dem  Ordner  "folder"  zu 
verschieben versuchte.  Das Verschieben von Ordnern ist auch unter TOS 1.4 
nicht m√∂glich,  so da√ü der MV- Befehl beim Behandeln von Ordnern √ºberhaupt 
nicht verwendet wird.

1.26 SHIFT
----------

Syntax: SHIFT
Zweck:  Die Parameter der Batchdatei verschieben
SHIFT schiebt den Parameter %1 nach %0,  %2 nach %1 usw.;  so k√∂nnen  auch 
mehr  als 10 Parameter verwendet werden oder in einer FOR - Schleife  eine 
Aktion f√ºr alle Parameter ausgef√ºhrt werden.

1.27 SET
--------

Syntax: SET
        SET symbol=
        SET symbol=wert
Zweck:  Environment manipulieren
Ohne Parameter wird das Environment ausgegeben. Mit "SET symbol=" wird die 
Environment- Variable <symbol> gel√∂scht,  mit "SET symbol=wert" auf  einen 
neuen Wert gesetzt.
Soll  der Wert Leerstellen enthalten,  setze man "symbol=wert"  in  Anf√ºh-
rungszeichen.
Bemerkung: Das Environment ist etwa 1kB gro√ü, also i.a. ausreichend.

1.28 SORT
---------

Syntax: SORT [-C] [-R] [-n]
Zweck:  Textdatei sortieren
^Z in der Datei wird als Dateiende erkannt.
SORT ist ein Filter.  Mit -C wird Gro√ü-/Kleinschreibung unterschieden. Mit 
-R wird umgekehrt sortiert.  -n enth√§lt die Position des Schl√ºssels;  z.B. 
vergleicht SORT -4 die Zeilen erst ab der vierten Spalte.
Es k√∂nnen nur Dateien sortiert werden, die ganz in den Speicher passen.

1.29 TIME
---------

(siehe DATE)
Wie DATE, nur mit Zeit statt Datum.

1.30 TOUCH
----------

Syntax: TOUCH datei1 datei2 ...
Zweck: Datum und Uhrzeit der Datei auf aktuelles Datum/Uhrzeit setzen, als 
ob sie ge√§ndert worden w√§re.  Das Archivbit (ab TOS 1.4 unterst√ºtzt)  wird 
nicht beeinflu√üt.
Als <datei> kann man auch einen Pfad angeben,  etwa "TOUCH \", dann werden 
alle Dateien auf dem Wurzellaufwerk in Uhrzeit und Datum aktualisiert.
Sinnvoll  ist  die  Anwendung  f√ºr ein MAKE,  das  man  so  zwingen  kann, 
Quelltexte  neu zu √ºbersetzen,  da sich jetzt ein neueres Datum haben  als 
die bereits erzeugten Objektdateien,  oder f√ºr den Fall,  da√ü man  Dateien 
mit dem nichtssagenden Datum 6.2.86 hat.

1.31 TREE
---------

(siehe CK)
Wie  CK,   es  werden  jedoch  nur  die  zul√§ssigen  Pfade  des  Laufwerks 
ausgegeben.

1.32 TYPE
---------

Syntax: TYPE datei1 datei2 ...
Zweck:  Datei(en) anzeigen
TYPE kann beliebig viele Argumente haben. Ist <datei> ein Dateimuster oder 
ein Pfad, werden alle passenden Dateien angezeigt. Die Dateinamen erschei-
nen  nur auf dem Bildschirm und werden nicht nach stdout  geschrieben.  Im 
Gegensatz  zu  "MORE" wird das Zeichen ^Z  nicht  ausgewertet,  damit  die 
Verkettung von Dateien auch bei solchen Dateien funktioniert,  die  dieses 
Zeichen enthalten.
Bemerkung: TYPE  wirkt wie CAT in UNIX.  Mit "TYPE datei1 datei2  >datei3" 
           kann  man  Dateien  verketten.   Dabei  bekommt  <datei3>,   im 
           Gegensatz zum COPY- Befehl, das aktuelle Datum.

1.33 VER
--------

Syntax: VER
Zweck:  TOS/KAOS- Version, GEMDOS- Version und CMD- Version anzeigen.
Die GEMDOS- Version hat nicht unbedingt etwas mit der TOS- Version zu tun.
Hier eine Aufstellung der bisher bekannten (deutschen!) Versionen f√ºr  den 
ST (ohne die f√ºr STE oder TT):

TOS  1.0 20/06/85, GEMDOS 0.13     Diskversion (uralt)
TOS  1.0 20/11/85, GEMDOS 0.19     Diskversion (erste "endg√ºltige")
TOS  1.0 06/02/86, GEMDOS 0.19     Diskversion
                                   ROMs ("Rom- TOS")
TOS  1.0 06/02/86, GEMDOS 0.20     dito mit Turbo-DOS
TOS  1.2 22/04/87, GEMDOS 0.19     ROMs ("Blitter TOS")
KAOS 1.2 22/04/87, GEMDOS 0.20     KAOS (Vorversion vom November '87)
KAOS 1.2 22/04/87, GEMDOS 0.21     KAOS 1.2.3  (vom Juli '88)
TOS  1.4 18/05/88, GEMDOS 0.21     Diskversion 1.4 (Beta Version)
TOS  1.4 08/08/88, GEMDOS 0.21     Diskversion 1.4 (Developer Version)
TOS  1.4 22/02/89, GEMDOS 0.21     ROMs 1.4        (Messe- Version)
TOS  1.4 06/04/89, GEMDOS 0.21     ROMs ("Rainbow" TOS 1.4)
KAOS 1.4 06/04/89, GEMDOS 0.22     KAOS 1.4.x


KCMD.ACC  gibt  hier  auch die AES- Versionsnummer  aus,  die  jedoch  von 
geringerem Interesse ist. TOS 1.0/1.2 geben hier $120 an (wird dezimal als 
V1.32 angezeigt), TOS 1.4 gibt $140 an (wird als V1.64 angezeigt) und KAOS 
1.4 $141 (also V1.65).  GEM 2.2 von ABC hat Versionsnummer $210 (als V2.16 
angezeigt).

1.34 VERIFY
-----------

Syntax: VERIFY
        VERIFY ON
        VERIFY OFF
Zweck:  Read/Write- Verify- Flag des BIOS anzeigen/√§ndern
Beim  Einschalten des Rechners ist das VERIFY- Flag (im Gegensatz  zu  MS-
DOS)  immer eingeschaltet.  Wenn man mit Diskette arbeitet,  kann man  die 
Schreibzugriffe  durch  "VERIFY  OFF"  stark  beschleunigen.   Daf√ºr  wird 
besonders bei billigen Disketten das Risiko etwas h√∂her, da√ü Schreibfehler 
nicht erkannt werden.
Das  Verify- Flag hat normalerweise nur Auswirkungen auf die Laufwerke  A: 
und B:,  es sei denn, ein anderes Treiberprogramm (Festplatte) fragt diese 
Systemvariable ebenfalls ab.


2. Externe Kommandos im BIN- Ordner
-----------------------------------

Auf  der  Diskette befinden sich im Ordner BIN einige  externe  Kommandos. 
Damit  man diese ohne Angabe des Pfadnamens starten kann,  sollte man  die 
PATH- Variable entsprechend setzen.

Alle  Kommandos sind reine TOS- Programme,  die Ausgaben nach  STDOUT  und 
Fehlermeldungen  nach Handle 4 (STDERR) oder direkt nach  CON:  schreiben. 
Sie geben als R√ºckgabewert DOS- Fehlercodes oder bei fehlerlosem Lauf eine 
0 zur√ºck.

Die externen Kommandos haben keine Versionsnummer. Neuere Versionen lassen 
sich nur am Datum der Programmdatei erkennen.

Startet man ein externes Kommando ohne Parameter,  erh√§lt man in der Regel 
eine kurze Erkl√§rung der m√∂glichen Parameter.

2.1 PRINT
---------

Syntax: PRINT {-[p][s][i][c][d]} datei1 datei2...
Zweck:  Textdatei(en) auf Epson- kompatiblen Druckern ausgeben
-tn  Tabulatorweite <n> Stellen
-p   Seitenvorschub nach jeder Datei
-s   Schmaler Zeilenabstand (1/8")
-i   Initialisierung vor jeder Datei
-c   Schmalschrift (Compressed)
-d   Breitschrift  (Double Width)

Die  Textdatei  wird ausgedruckt,  wobei  alle  nationalen  Sonderzeichen, 
soweit m√∂glich,  in Epson- Zeichen √ºbersetzt werden. Einige Zeichen werden 
daf√ºr neu definiert.

Beim  Ausdrucken h√§lt eine beliebige Taste die Ausgabe an,  CTRL-C  bricht 
den laufenden Druckvorgang sofort ab. Wenn kein Drucker eingeschaltet oder 
dieser OFF-LINE ist,  kann der Druckvorgang ebenfalls abgebrochen  werden, 
ohne auf die ber√ºhmt- ber√ºchtigten 30sec. "Time-Out" zu warten.

PRINT  spricht  den Drucker √ºber die Standarddatei stdprn  an.  Durch  die 
Korrektur  der  Ein-/Ausgabeumlenkung  einschlie√ülich  der  Statusabfragen 
(z.B.  Cprnos()) ist es unter KAOS v√∂llig problemlos m√∂glich,  die Ausgabe 
von PRINT in eine Datei oder auf den Bildschirm zu lenken, etwa mit "PRINT 
datei  3>datei.prt".   F√ºr  andere  TOS-  Versionen  wage  ich  es  nicht, 
Vorhersagen zu treffen...

2.2 CRASHDMP
------------

Syntax: CRASHDMP
Zweck:  Daten der letzten Exception (Bomben) anzeigen
Die Art der letzten Exception (z.B.  Busfehler) sowie alle Registerinhalte 
bei  deren Auftreten werden lesbar nach stdout geschrieben.  Im Fall  Bus- 
oder  Adre√üfehler  werden die obersten Eintr√§ge des  Supervisorstacks  bei 
Auftreten der Exception ebenfalls dekodiert.  Man erh√§lt Informationen wie 
etwa  :  "Adre√üfehler  bei PC=xxx,SR=xxx und Lesezugriff im  Usermode  auf 
Adresse xxx, verantwortlicher Maschinenbefehl: xxx".
Besonders  hier ist die Umlenkung CRASHDMP >datei f√ºr  sp√§tere  Verwendung 
sinnvoll.

2.3 EXE2BIN
-----------

Syntax: EXE2BIN dateimuster/pfad
Zweck:  Programmdateien in ein Spezialformat umwandeln
Auf die Extension .PRG und .TOS und .TTP kann verzichtet  werden,  EXE2BIN 
erg√§nzt  sie automatisch.  Bei Angabe von Pfaden oder Dateimustern  werden 
alle passenden Dateien bearbeitet.
Programme ohne Relocation- Daten (also "position independent") k√∂nnen  vom 
GEMDOS  sehr viel schneller als normale Programme  geladen  werden.  Dabei 
werden  weder  das BSS- Segment noch der √ºbrige freie  Speicher  gel√∂scht, 
bevor das Programm gestartet wird.
EXE2BIN pr√ºft nun, ob das Programm "position independent" ist, und wandelt 
es dann in eine Art COM- Format um. Man hat dabei selbst darauf zu achten, 
da√ü sich das Programm nicht auf ein gel√∂schtes BSS- Segment verl√§√üt.
Wird EXE2BIN unter KAOS gestartet,  wird die Fshrink- Funktion benutzt, um 
die  nun nutzlosen (Null-) Relocationdaten von der Datei zu entfernen  und 
diese so zu k√ºrzen.
Ab TOS 1.4 gibt es ein sogenanntes "Fastload- Bit" im Programmheader,  das 
bewirkt,  da√ü nicht mehr der gesamte freie Speicher,  sondern nur noch das 
BSS gel√∂scht wird. EXE2BIN fragt nun ab, ob dieses Bit bereits gesetzt ist 
und,  wenn  nicht,  setzt es.  Dabei bleiben Datum und Uhrzeit  der  Datei 
explizit erhalten.

2.4 LABEL
---------

Syntax: LABEL                        Diskname anzeigen
        LABEL x:                     Diskname von Laufwerk x: anzeigen
        LABEL name                   Disk benamsen
        LABEL x:name                 Disk in Laufwerk x: benamsen
Zweck:  Diskettennamen anzeigen, setzen oder l√∂schen
Wird als neuer Name "-" angegeben, wird der Diskname, falls vorhanden,
einfach gel√∂scht.
LABEL funktioniert bei allen Diskettenarten,  Harddisk,  Ramdisk usw.  und 
mit s√§mtlichen TOS- Versionen.
LABEL gibt GEMDOS- Fehlercodes zur√ºck, falls etwas nicht funktioniert hat.

2.5 FC
------

Syntax: FC [-s] [datei1 [datei2|pfad2]]
Zweck: Dateien vergleichen (ab Adresse <s>)
Die  beiden Dateien werden Byte f√ºr Byte eingelesen  und  verglichen.  Die 
Unterschiede werden als Hex- und Ascii- Codes nach stdout geschrieben.
Sind die Dateil√§ngen unterschiedlich,  wird abgebrochen.  Ebenso kann  man 
die Ausgabe auf den Bildschirm mit CTRL-C abbrechen.
Wird  FC  ohne  Parameter  gestartet,  werden  die  Dateinamen  von  STDIN 
eingelesen.
Endet der zweite Parameter auf ':' oder '\',  wird angenommen, da√ü es sich 
um  eine  Pfadangabe  handelt.  Der  reine  Dateiname  wird  von  <datei1> 
extrahiert und an <pfad2> angeh√§ngt.
Wird nur ein Parameter angegeben,  wird als zweiter Parameter das aktuelle 
Verzeichnis angenommen.
Mit Hilfe dieser beiden M√∂glichkeiten wird es leicht, gleichnamige Dateien 
in verschieden Pfaden zu vergleichen.
Bei mehr als zwei Parametern wird die Syntax ausgegeben.

2.6 KILLRAM
-----------

Syntax: KILLRAM
Zweck:   Ausschalter simulieren;  'N','n' und rechte Maustaste brechen ab, 
alle   anderen   Tasten  und  die  linke   Maustaste   f√ºhren   aus.   F√ºr 
Tastatureingaben wird auch der MIDI- Port abgefragt.

2.7 ASTOWORD.TTP
----------------

Syntax: ASTOWORD asciidatei
Zweck:  Konvertiert Datei von ASCII->WORDPLUS
Die Ausgabedatei hat denselben Namen wie die Eingabedatei,  jedoch mit der 
Extension ".doc". Existiert solch eine Datei schon, wird sie gel√∂scht.

2.8 WORDTOAS.TTP
----------------

Syntax: WORDTOAS datei[.doc]
Zweck:  Konvertiert Datei von WORDPLUS->ASCII
Enth√§lt  <datei>  keine oder eine andere Extension als  ".doc",  wird  als 
Extension ".doc" eingesetzt.

Die Ausgabedatei hat denselben Namen wie die Eingabedatei,  jedoch mit der 
Extension ".txt". Existiert solch eine Datei schon, wird sie gel√∂scht.

2.9 DUMP.TTP
------------

Syntax: DUMP [-bci] [[-[s]hhhhhh[-hhhhhh]] datei]
Zweck:  Hex-/Ascii/C- Dump von allen Dateien (auch CON:)
Das  Programm ersetzt das gleichnamige Programm im  Entwicklungspaket  von 
Atari,  ist  jedoch  k√ºrzer (2k statt 10k) und gibt  auch  solche  Dateien 
korrekt aus,  die nicht ein Vielfaches von 16 Bytes L√§nge haben.  Au√üerdem 
kann die Ausgabe als Eingabe f√ºr einen C-Compiler benutzt werden.
Das  Zeichen  "s"  im  Schalter zur Angabe  der  Startadresse  (Hex)  kann 
weggelassen werden.
Ist  die Datei "CON:",  kann die Eingabe mit ^C,  einer leeren Zeile  (nur 
Return) oder einer Zeile abgebrochen werden, die nur ^Z enth√§lt.
Die Schalter b,c,i sind f√ºr die Ausgabe als C-Quelltext (Schalter "c") und 
bedeuten "mit Kommentar" ("i"), "byteweise" ("b").

2.10 SPLIT.TTP
--------------

Syntax: SPLIT [-t] [-[s]hhhhhh] datei [ziel1 [ziel2]]
Zweck:  (Text-) <datei> in <ziel1> und <ziel2>  aufspalten
Wenn  der Schalter -t angegeben wurde,  wird die Datei immer hinter  einem 
Zeilenende  aufgespalten,  dieser Schalter mu√ü also immer  dann  angegeben 
werden, wenn es sich um eine Textdatei handelt.
Wird keine Aufspaltposition (-shhhhhh,  hexadezimal) angegeben,  wird  die 
Datei m√∂glichst in der Mitte zerlegt.
Werden  die  Parameter <ziel1> und <ziel2> nicht angegeben,  so  wird  der 
erste Teil von <datei> in eine neue Datei __EINS__ geschrieben.  Wird  nur 
<ziel1>  angegeben,  so wird nur der erste Teil der <datei>  nach  <ziel1> 
geschrieben, bei Angabe von <ziel2> der zweite Teil nach <ziel2>.
Will man nur den zweiten Teil der Datei abspalten,  kann man <ziel1> unter 
KAOS als NUL oder NUL: angeben.
Beispiel:  SPLIT -1c CMD.PRG NUL CMD.XXX
           schreibt  die Datei CMD.PRG ohne die ersten 28 Bytes  Programm-
           header nach CMD.XXX


3. Stdout/Stdin- Umlenkung
--------------------------

Wie  MS-DOS  und  UNIX hat auch GEMDOS sogenannte  Standard-  Dateien  und 
physikalische Dateien.
Die Standard- Dateien haben die Handle- Nummern 0 bis 5, dabei sind:

  0  "stdin",  Standard- Eingabe     (normalerweise Tastatur)
  1  "stdout", Standard- Ausgabe     (normalerweise Bildschirm)
  2  "stdaux", Standard- Hilfsdatei  (normalerweise RS-232)
  3  "stdprn", Standard- Druckdatei  (normalerweise Centronics)
  4  "stderr", unbenutzt             (bei KAOS und ab TOS 1.4: Bildschirm)
  5  "stdxtra" unbenutzt             (bei KAOS und ab TOS 1.4: Bildschirm)

Alle  Standarddateien (0 bis 5) k√∂nnen mit der DOS- Funktion Fforce()  auf 
jede  beliebige  Datei oder jedes beliebige Ger√§t  umgelenkt  werden.  Die 
"normalen"  Dateien  dagegen  (Handles 6 bis 75)  k√∂nnen  nicht  umgelenkt 
werden.

Weitere Information:  siehe ST 4/87 :  "Die XENIX - Struktur des  GEMDOS". 
Die  Umlenkung ist jedoch nicht so problemlos,  wie es den  Anschein  hat. 
Neben  der total verkorksten Behandlung der Standardpfade liegen hier  die 
schlimmsten Fehler des GEMDOS (in Fforce(), Fdup(), Fclose()).

Im  Gegensatz  zu COMMAND.COM unter MS-DOS kann CMD  unter  TOS  s√§mtliche 
6  Standarddateien  auf  der  Kommandozeile  umlenken.  Bei  den  internen 
Befehlen des CMD (z.B.  DIR >dirlist) funktioniert die Umlenkung  problem-
los.  Beim  Aufruf von (externen) Programmen (z.B.  SID >list) konnte  man 
bisher  auch  beim  TOS 1.2 die Ausgabe nicht  umlenken,  da  die  gesamte 
zeichenorientierte  Ausgabe nicht funktioniert.  Diese Fehler  sind  unter 
KAOS v√∂llig und ab TOS 1.4 z.T. behoben.
Umlenkungen werden in folgender Form eingegeben:

>datei              Erstellt <datei>, lenkt STDOUT auf <datei>
>>datei             H√§ngt STDOUT an <datei> an. Erstellt ggf. <datei>
<datei              Lenkt STDIN auf <datei>, falls diese existiert
pgm | .. | pgm      Pipe
n>datei             f√ºr 0 <= n <= 5 : Wie oben, aber mit bel. Std.datei
n>>datei            f√ºr 0 <= n <= 5 : Wie oben, aber mit bel. Std.datei

Die  Ausgabedatei wird bei '<' zum Lesen,  bei '>' und '>>' zum Lesen  und 
Schreiben  ge√∂ffnet.   Die Eingaben  "pgm  >out"  und  "pgm  1>out"   sind 
√§quivalent.  Die Handles 2..5 k√∂nnen nicht mit '<' umgelenkt werden; daher 
werden sie immer zum Lesen und Schreiben ge√∂ffnet und ggf.  erstellt.  Bei 
der Umlenkung von STDAUX (mit "2>datei") wird sowohl die Ein- als auch die 
Ausgabe auf die serielle Schnittstelle unter DOS umgelenkt.  Es sind  also 
sowohl  die  Befehle Cauxout(),  Cauxos() als auch Cauxin()  und  Cauxis() 
betroffen.  Es ist im √ºbrigen nicht zu empfehlen, STDIN auf den Drucker zu 
lenken, da man von dort nicht viel lesen kann...

Auch eine Pipe kann umgelenkt werden, z.B. "DIR | SORT >dirlist".

Als  Kommandos  zwischen  dem ersten und letzten "|" der  Pipe  kommen  in 
erster Linie "Filter" in Frage, also solche Programme, die von stdin lesen 
und nach stdout schreiben.

F√ºr  die  Pipes werden normalerweise im  Wurzelverzeichnis  des  aktuellen 
Laufwerks tempor√§re Dateien mit Namen "\$$PIPE?.?" erstellt.  Daher  soll-
ten sich keine Dateien dieses Namens dort befinden,  und au√üerdem darf das 
aktuelle  Laufwerk  nicht schreibgesch√ºtzt  sein.  Ist  eine  Environment- 
Variable  TMPDIR vorhanden,  werden die tempor√§ren Dateien  dort  erstellt 
(inzwischen  ist  der Hersteller von MS-DOS auch auf  den  Dreh  gekommen, 
Version 5.0 macht es genauso,  wie CMD es seit Jahren tut). Beispielsweise 
bei  TMPDIR=c:\tmp oder TMPDIR=c:\tmp\ hei√üen die tempor√§ren Dateien  dann 
c:\tmp\$$pipe?.?.  Durch  dieses praktische Feature l√§√üt  sich  erreichen, 
da√ü Pipes immer auf dem schnellsten Speichermedium,  also auf Ramdisk oder 
Festplatte  angelegt werden,  auch wenn man sich gerade "auf der  Diskette 
befindet".

Ein Anwendungsbeispiel f√ºr das Umlenken einer anderen Standarddatei:
"PRINT drucktext 3>out"

Ruft  das Programm "PRINT" (s.u.) auf mit umgelenkter STDPRN-  Datei.  Die 
Datei  drucktext  wird  jetzt nicht direkt auf  den  Drucker  geschrieben, 
sondern  einschlie√ülich  aller Steuerzeichen in die  Datei  "out".  Ebenso 
k√∂nnte man mit:

"PRINT drucktext 3>con"

den f√ºr Epson- Drucker √ºbersetzten Text auf den Bildschirm  schreiben.  So 
lassen sich gut eigene oder fremde Programme testen,  die eine Ausgabe auf 
den  Drucker  machen.  Das  Resultat l√§√üt sich hinterher  exakt  mit  DUMP 
analysieren.

Ich empfehle,  eigene Programme so zu schreiben,  da√ü der Standardkanal  4 
f√ºr die Fehlerausgabe (STDERR) verwendet wird.
Mit:

"PGM 4>prn"

k√∂nnte man dann z.B.  alle Fehlermeldungen auf den Drucker lenken. Man mu√ü 
allerdings  vorher  pr√ºfen,  ob der Standardkanal 4 g√ºltig ist  (etwa  mit 
Fdup),  dies ist f√ºr TOS- Versionen vor 1.4 notwendig,  KAOS bereitet auch 
in der Version 1.2.3 keine Probleme.


4. Ger√§te (Devices)
-------------------

TOS kennt 3 Ger√§te,  die wie normale Dateien behandelt werden,  z.B.  kann 
die Standard- Ausgabe auf den Drucker gelenkt werden:

1) CON:   Bildschirm/Tastatur
2) AUX:   RS-232
3) PRN:   Drucker

Mit  "TYPE  datei >AUX:" kann man z.B.  einfach Daten  √ºber  die  serielle 
Schnittstelle schicken.
Im Gegensatz zu MS-DOS fehlt erstens das Ger√§t "NUL:", zweitens k√∂nnen die 
Doppelpunkte √ºnicht weggelassen werden.

Unter KAOS gilt:
1)   Es gibt das Ger√§t NUL:
2)   Auch "con","a:\Con" oder "con.c" usw. werden als Ger√§te erkannt, dies 
     wegen der behaupteten Kompatibilit√§t zu MS-DOS.
3)   Das Erstellen von Ordnern mit Ger√§tenamen sowie das Umbenennen in ein 
     Ger√§t wird von KAOS abgewiesen.


5. Kommandozeilen- Auswertung
-----------------------------

Vor  Ausf√ºhrung  jeder Kommandozeile (ob von Tastatur oder  Batch-  Datei) 
werden Parameter voneinander getrennt, evtl. Datei - Umlenkungen vorgenom-
men und Environment- Variable ausgewertet.  Das Trennzeichen ist immer die 
Leerstelle,  w√§hrend  unter  MS-DOS auch das  Komma  zugelassen  ist.  Mit 
Setzen in Anf√ºhrungszeichen wird die Auswertung verhindert.  Eine Zeichen-
kette in Anf√ºhrungszeichen ist immer ein ganzer Parameter,  egal, ob davor 
oder  dahinter  oder  dazwischen  Leerzeichen  oder  andere  Sonderzeichen 
('>','<','|','%') stehen oder nicht.  Die Auswertung von Variablen wie  %1 
oder  %path%  oder  Steuerzeichen wie %\n%  kann  durch  Einklammerung  in 
Hochkommata verhindert werden.

"......"          ... ist EIN Parameter, kann ' oder SPACE enthalten.
'......'          Wertet ... nicht aus, kann " oder SPACE enthalten.
%var%             Gibt Wert von var (mit SET gesetzt) an, falls vorhanden.
%%                Das '%'- Zeichen selbst
%\n%              Zeilenvorschub (Line Feed)
%\r%              Wagenr√ºcklauf  (Carriage Return)
%\b%              R√ºckschritt    (Backspace)
%\t%              Tabulator

Beispiel: SET "f1=dir -q%\n%" belegt eine Funktionstaste.  Beim  Bet√§tigen 
          wird der Befehl automatisch ausgef√ºhrt.

Im Gegensatz zu UNIX werden Environment- Variable in '%' eingeklammert, um 
-das  Ende  des  Variablennamens  deutlich  zu  markieren;   Ausdr√ºcke  wie 
"$(pfad)/datei"  (UNIX) sind daher nicht notwendig,  man schreibt  einfach 
"%pfad%\datei".

Bemerkung: MS-DOS  kennt weder die einfachen Anf√ºhrungszeichen ',  um  die 
           doppelten Anf√ºhrungszeichen " innerhalb eines Parameters einge-
           ben zu k√∂nnen,  noch die M√∂glichkeit, Environment- Variable mit 
           Hilfe des % - Zeichens innerhalb der Eingabezeile einzusetzen.


6. Editor- Steuertasten
-----------------------

Wegen der vielen Fehler des Systemaufrufs Cconrs() (falsche Behandlung von 
Umlauten,  falsche  Reaktion bei √úberlauf des Eingabepuffers,  Fehler  bei 
Eingaben  √ºber ein Zeilenende hinaus) enth√§lt CMD eine eigene Routine  zur 
Eingabe einer Zeile. Sie wird benutzt bei der Eingabe eines Kommandos, bei 
DATE und TIME.  Da von stdin gelesen wird, kann die Eingabe auch umgelenkt 
werden.

Der  gr√∂√üte Vorteil der eigenen Eingaberoutine ist  die  M√∂glichkeit,  die 
Funktionstasten  frei zu definieren.  Die Belegung dieser Tasten steht  im 
Environment, wird also mit dem SET- Befehl vorgenommen. Ein Beispiel:

  SET "f1=edit "

belegt die Funktionstaste F1 mit der Zeichenkette "edit ".  Wenn wie  hier 
die Zeichenkette Leerstellen enth√§lt, mu√ü der Parameter des SET- Kommandos 
in Anf√ºhrungszeichen gesetzt werden.  F√ºr die Taste F10 mu√ü F0 geschrieben 
werden. Sinnigerweise sollten die Funktionstasten- Belegungen zusammen mit 
der PATH- Definition in der AUTOEXEC.BAT- Datei stehen.
Folgende Sondertasten werden benutzt:

F1..F10             Je nach Belegung
TAB                 Cursor an Anfang/Ende der Eingabe
BS                  Zeichen links von Cursor l√∂schen
DEL                 Zeichen unter Cursor l√∂schen
RETURN              Eingabe abschlie√üen, Befehl in UNDO- Puffer
ENTER               Eingabe abschlie√üen
INSERT              Einf√ºge- /√úberschreibmodus wechseln
CLR                 Eingabe l√∂schen
UNDO                letzte Eingabe aufrufen
Cursor L/R          Cursor bewegen

Unter KAOS gilt:

  Es wird einfach der Cconrs- Aufruf (bzw.  Fread(STDIN,...) benutzt. KAOS 
  enth√§lt komplett den oben beschriebenen Editor, der damit jedem Programm 
  zug√§nglich ist.  Damit sind unter jedem Programm, das von KCMD gestartet 
  wurde,  die Funktionstasten belegt (z.B. SID,PROBE,PASCAL- Programme mit 
  readln(), FORTRAN- Programme mit READ(*,*) usw.).

  In  KAOS 1.4 ist der Zeileneditor noch einmal verbessert  und  erweitert 
  worden, siehe dortige Dokumentation!


7. Starten von Programmen (Externe Kommandos)
---------------------------------------------

Die  Programme  auf  der Diskette/Harddisk werden  als  externe  Kommandos 
bezeichnet.  Insbesondere  gilt  das f√ºr  solche,  die  die  Kommandozeile 
auswerten  (i.a.  alle  TTPs).  Bei der Umlenkung  der  Standardein-  bzw. 
Ausgabe  ist darauf zu achten,  da√ü einige Laufzeitsysteme  von  Compiler-
sprachen  von  sich  aus die Kommandozeile  nach  Eintr√§gen  wie  ">datei" 
absuchen  und  die  Ausgabe selbst  umlenken.  Will  man  diese  Umlenkung 
benutzen,  mu√ü man den Ausdruck ">datei" in Anf√ºhrungszeichen  setzen,  um 
die Auswertung durch CMD zu verhindern.

An  das aufrufende Programm wird au√üer der Kommandozeile auch  eine  Kopie 
des (durch SET anzeigbaren) Environments √ºbergeben.  Das Programm kann  so 
alle Eintr√§ge des Environments verwenden,  ohne sie jedoch zu √§ndern (z.B. 
die PATH- Variable oder die Funktionstasten- Definitionen). Am einfachsten 
zeigt sich dieser Effekt,  wenn man von CMD aus einfach noch einmal  "CMD" 
eingibt.

N√ºtzlich  ist  die Einrichtung der PATH-  Variablen,  die  es  erm√∂glicht, 
externe  Kommandos  aufzurufen,  die sich nicht im  aktuellen  Verzeichnis 
befinden, ohne lange Pfadangaben zu machen. Beispiel:

Sei  PATH=p1;p2;  gesetzt und als Kommando  "edit"  eingegeben.  Kommandos 
werden in folgender Reihenfolge gesucht:

- Internes Kommando "edit"
- Batchdatei   "edit.bat",    "edit.btp"
- TOS-Programm "edit.ttp",    "edit.tos"
- GEM-Programm "edit.prg",    "edit.app"
- Batchdatei   "p1\edit.bat"  "p1\edit.btp"
- TOS-Programm "p1\edit.ttp", "p1\edit.tos"
- GEM-Programm "p1\edit.prg", "p1\edit.app"
- Batchdatei   "p2\edit.bat", "p2\edit.btp"
- TOS-Programm "p2\edit.ttp", "p2\edit.tos"
- GEM-Programm "p2\edit.prg", "p2\edit.app"

Man kann den Dateityp auch explizit angeben (z.B.  "edit.prg"),  wenn  man 
verhindern will,  da√ü eine gleichnamige Batchdatei o.√§.  aufgerufen  wird. 
Der  Dateityp .ACC wird nicht automatisch gesucht,  wenn  keine  Extension 
eingegeben wurde,  kann aber explizit etwa mit "C:\KAOSCONF.ACC" gestartet 
werden.  Programme  mit Extension .ACC werden wie Programme mit  Extension 
.PRG oder .APP im Grafikmodus gestartet.

Gibt man einen expliziten Pfad an,  z.B. "a:edit", wird die PATH- Variable 
nicht verwendet und nur im angegebenen Directory gesucht.

Achtung:  Beim Betrieb als Accessory werden Kommandos,  die auf .PRG  oder 
.APP enden,  nicht automatisch gesucht und daher nicht gefunden,  wenn man 
keine Extension eingibt.  Dies ist als Vorsichtsma√ünahme n√∂tig,  da GEM es 
nicht schafft,  mehrere Applikationen gleichzeitig zu  verwalten.  Startet 
man  etwa  WORDPLUS von WORDPLUS aus,  gibt  es  Bombenterror.  Eigentlich 
k√∂nnte ja AES diesen (h√§ufig auftretenden) Fall abfangen, aber leider...
Will man trotz aller Warnungen ein Programm mit Endung .PRG  starten,  mu√ü 
man die Extension mit eingeben.

GEM-  Programme  werden  mit Mauszeiger und  ohne  Cursor  gestartet.  Der 
etv_critic-  Handler  des DESKTOP wird  installiert  (Diskettenfehler  per 
Alertbox  anzeigen).  Der Bildschirm wird bei Aufruf des  Programms  nicht 
gel√∂scht. Man kann dies aber vorher durch CLS tun.

TOS-  Programme oder Batch- Dateien werden mit Cursor und ohne  Mauszeiger 
gestartet. Der etv_critic- Handler des CMD bleibt installiert.

Ansonsten  besteht kein Unterschied zwischen dem Aufruf von GEM- und  TOS- 
Programmen.   Selbstverst√§ndlich   k√∂nnen  Parameter  an  GEM-   Programme 
√ºbergeben  werden.  Ob  diese auch ausgewertet  werden,  ist  eine  andere 
Frage...  Die  Dateiarten  BAT/BTP und TOS/TTP und PRG/APP  sind  f√ºr  CMD 
jeweils √§quvalent.  Der Dateityp BTP existiert f√ºr die speziellen  Freunde 
von Neodesk.

Nach dem Aufruf jedes Programmes wird dessen R√ºckgabewert untersucht.  Ist 
er  negativ,  wird er als DOS- oder BIOS- Fehlercode interpretiert und  im 
Klartext ausgegeben.  Beim Designen eigener Programme kann man  beispiels-
weise so kodieren:

     if   (0 > (handle = Fopen("program.hlp",O_RDONLY)))
          exit(handle);       /* Mit DOS- Fehlercode beenden */

oder:

     if   (NULL == (ptr = (char *) Malloc(10240L)))
          Pterm((int) ENSMEM);

statt:
     if   (...)
          {
          fprintf(stderr,"Nicht gen√ºgend Speicher!\n");
          exit(1);
          }

Das  spart nicht nur Tipparbeit,  sondern grenzt den Fehler  (unter  KAOS, 
denn TOS liefert h√§ufig falsche Codes) h√§ufig auch noch besser  ein,  z.B. 
im oberen Fall:
  "Datei nicht gefunden"
  "Pfad nicht gefunden"
  "Ung√ºltiges Laufwerk"
  "Interner Fehler"
  "Nicht gen√ºgend (interner) Speicher"
  "Nicht gen√ºgend Dateihandles"
  "Spur nicht gefunden"
  "CRC- Fehler"
  "Sektor nicht gefunden"
  "Laufwerk nicht bereit"


8. Batch- Dateien
-----------------

Das  Konzept  der Batch- Datei entspricht im wesentlichen dem  im  MS-DOS. 
Batch- Befehle sind GOTO,SHIFT,IF,END,FOR,PAUSE.

Das Label f√ºr GOTO sieht so aus:  ":label". Es steht am Zeilenanfang einer 
Zeile der Batchdatei. Steht dahinter ein Leerzeichen, so wird alles rechts 
von dem Leerzeichen stehende ignoriert. Mit ": Kommentar" kann man so eine 
Batchdatei  kommentieren,  ein  Befehl REM des MS-DOS wird bei  CMD  nicht 
ben√∂tigt.

Das ECHO- Flag wirkt bei CMD nur auf die Ausf√ºhrung von  Batchdateien.  Es 
ist  normalerweise (anders als bei MS-DOS) ausgeschaltet und  braucht  nur 
mit ECHO ON eingeschaltet zu werden, wenn man eine komplizierte Batchdatei 
verfolgen m√∂chte.

Batchdateien k√∂nnen verschachtelt werden,  die neue Batchdatei erh√§lt auch 
neue Parameter. Bis zu 3 Ebenen sind m√∂glich.

Eine Batchdatei kann mit CTRL-C abgebrochen werden.  Nach jeder Ausf√ºhrung 
einer  Kommandozeile  pr√ºft CMD,  ob CTRL-C im  Tastaturpuffer  steht.  In 
diesem  Fall wird der gesamte Batchproze√ü sofort unterbrochen,  also  auch 
bei Verschachtelung der Batchdateien sofort die n√§chste Kommandozeile  von 
der Tastatur erwartet.

Enth√§lt  das  Kommando zum Aufruf einer Batchdatei eine  Ein-/  Ausgabeum-
lenkung (f√ºr irgendeinen oder mehrere der 6 Standard- Kan√§le), so gilt (im 
Gegensatz  zu  MS-DOS)  die  Umlenkung  f√ºr  die  ganze  Batchdatei.  Soll 
innerhalb  der  Batchdatei  eine  Ausgabe  unbedingt  auf  den  Bildschirm 
ausgegeben werden, kann man z.B. schreiben:

"ECHO string >CON:"

Die  folgenden  Zeilen der Batchdatei verwenden wieder den f√ºr  die  ganze 
Batchdatei g√ºltigen Ausgabekanal.


9. CMD als Accessory. Allgemeines und spezielles 
------------------------------------------------

CMD ist ein Programm, da√ü, einmal gestartet oder aktiviert, v√∂llig auf GEM 
verzichtet. Es ist in seiner Funktion v√∂llig von DOS abh√§ngig.
Ein Accessory l√§uft bei GEM unter einer eigenen "Applikation",  aber unter 
demselben "Proze√ü" wie das gerade laufende Hauptprogramm.  Das hei√üt,  da√ü 
es  sich  f√ºr  AES um zwei verschiedene Applikationen,  f√ºr  DOS  aber  um 
denselben   Proze√ü   handelt.   Gerade  letzteres  f√ºhrt   zu   ziemlichen 
Schwierigkeiten, da KCMD.ACC f√ºr DOS kein eigenst√§ndiges Programm ist.
DOS merkt sich bei den folgenden Resourcen, welchem Proze√ü sie angeh√∂ren:

1)   ge√∂ffnete Dateien
2)   Speicherbl√∂cke (per Malloc geholt)
3)   Standardpfade
4)   Standardlaufwerk
5)   Standarddateien.

Anhand   des   PD   (Proze√üDeskriptor)  w√§hlt   DOS   zum   Beispiel   das 
Standardlaufwerk aus,  so wie etwa VDI anhand des Ger√§tehandles die gerade 
eingestellte   F√ºllfarbe   verwendet.   Ein  Accessory,   das   etwa   das 
Standardlaufwerk   oder  einen  Pfad  √§ndert,   w√ºrde  das   Hauptprogramm 
beeinflussen und ggf.  in Schwierigkeiten bringen. Andererseits m√º√üten bei 
jeder  Aktivierung  des  Accessories die  Pfade  und  Standarddateien  vom 
Hauptprogramm wieder √ºbernommen werden.

Die  Antwort  auf  die  L√∂sung  all  dieser  Probleme  ist  einfach,   die 
Realisierung schon schwieriger:

Man m√º√üte KCMD.ACC als EIGENEN Proze√ü laufen lassen.
Wie teilt man AES eine neue Applikation mit : appl_init()
Wie identifiziert AES eine Applikation: durch eine ap_id ("Handle")
Wie l√∂scht man diese Applikation wieder: appl_exit()
Wie teilt man VDI eine neue "Workstation" mit: v_opnvwk()
Wie identifiziert VDI eine "Workstation": durch ein Handle
Wie l√∂scht man eine solche wieder: v_clsvwk()

Wie erzeugt man einen neuen Proze√ü: durch Pexec()
Wie identifiziert DOS einen Proze√ü: durch den PD (Basepage)
Wie l√∂scht man einen Proze√ü: mit Pterm() oder Ptermres()

Leider  verwaltet das altmodische GEMDOS keine "Proze√ühandles",  die  sich 
wie in moderneren Betriebssystemen erzeugen und wieder l√∂schen lassen.
Was  bleibt also:  Pexec() erzeugt einen neuen Proze√ü.  Der Modus 0  kommt 
nicht in Frage, er l√§dt eine Programmdatei, das m√∂chten wir vermeiden. Die 
Modi  5  (Basepage  anlegen)  und  dann  4  (starten)  k√∂nnten  vielleicht 
funktionieren.

Was passiert aber mit unserem Proze√ü,  wenn er per "exit"  verlassen wurde 
und die Hauptapplikation wieder zum Zug kommen soll?  Nehmen wir etwa  an, 
wir  haben f√ºr Laufwerk A:  den Standardpfad "\texte",  und die Disk  wird 
gewechselt,  w√§hrend das Accessory nicht aktiv ist.  Wie ist es umgekehrt, 
wenn die Hauptapplikation den Pfad "a:\meinetexte" hat, und wir m√ºssen die 
Disk wechseln, w√§hrend KCMD.ACC aktiv ist.

Die Antwort auf alle diese Fragen ist: Durcheinander

Es sei denn, man verwendet KAOS:

KAOS  behandelt bei Diskwechseln nicht nur den laufenden  Proze√ü,  sondern 
auch alle Vorg√§nger (√ºber p_parent verkettet).  Nur so ist sichergestellt, 
da√ü  auch  die "schlafenden" Prozesse nicht "abgeh√§ngt"  werden  und  alle 
Diskwechsel mitbekommen √ºber:

1)   Ung√ºltigmachen des aktuellen Pfades (zur√ºck zur Root)
2)   Ung√ºltigmachen aller Standarddateien, die auf der alten Disk liegen

Also  l√§uft  KCMD.ACC  ohne gr√∂√üere √úberraschungen  nur  unter  KAOS.  Die 
Umschaltung  der  Prozesse geschieht ganz problemlos √ºber die ab  TOS  1.2 
dokumentierte  Systemvariable  _run,  die im TOS-  Header  enthalten  ist. 
Diese Methode ist einfacher als das Erzeugen einer Basepage o.√§.

Wird  KCMD.ACC vor Aktivieren des Desktop zur  Initialisierung  gestartet, 
passiert folgendes:

Die Basepage von KCMD.ACC (die bisher f√ºr GEMDOS unbekannt ist),  wird als 
Proze√ü  unter den Ur-PD eingeh√§ngt (das Gro√üelter des  Desktop).  So  kann 
KCMD.ACC alle Diskwechsel mitbekommen,  solange es  schl√§ft.  Anschlie√üend 
wird einfach in den event-multi gesprungen.

Wird KCMD.ACC nun aktiviert, tut sich folgendes:

KCMD.ACC  h√§ngt  seine  Basepage  aus  der  Kette  der  Prozesse  aus  und 
installiert wieder NULL als Ur-Gro√üelter des Desktop.  Anschlie√üend  h√§ngt 
sich  KCMD.ACC √ºber die laufende Applikation.  F√ºr GEMDOS sieht  es  jetzt 
also so aus,  da√ü KCMD.ACC von der Hauptapplikation √ºber Pexec() gestartet 
wurde.  Schlie√ülich wird die Variable _run auf KCMD.ACC geleitet, also f√ºr 
GEMDOS der neue Proze√ü gestartet.

Bei  der  Eingabe  von "exit" wird wieder _run  auf  die  laufende  Haupt- 
Applikation gelegt und KCMD.ACC als Ur-Gro√üelter des Desktop installiert.

Durch diese Vorgehensweise wird erreicht,  da√ü sowohl AES als auch  GEMDOS 
das Accessory als eigenst√§ndige Applikation bzw.  Proze√ü ansehen und es zu 
keinen "Besitzstreitigkeiten" oder "Kompetenzproblemen" kommt.


Gro√üe  Probleme bereitet das Starten von Programmen von  Accessories  aus. 
Die  Erfahrung  mit verschiedenen  Accessories  (STOOLS,  Schr√∂ttle-Shell) 
zeigte folgendes Verhalten:

- Applikationen  (Programme  unter  GEM) D√úRFEN  NICHT  gestartet  werden. 
  Bisher kann AES nur eine Applikation gleichzeitig verwalten.
- Das Starten von TOS- Programmen unter DESKTOP ist m√∂glich
- Das  Starten  von TOS- Programmen unter anderen Applikationen  ist  zwar 
  zun√§chst   m√∂glich,   die  Eingabe  von  "exit"  zur  R√ºckkehr  in   die 
  Hauptapplikation endet jedoch IMMER mit einem Systemabsturz.

Der Grund f√ºr das letztere Verhalten ist folgendes:

GEMDOS legt f√ºr jeden Proze√ü einen Supervisor- Stack an.  Dieser wird  f√ºr 
Interrupts  genutzt;  auch die R√ºcksprungadresse von einem Trap wird  hier 
aufbewahrt.  Leider ist dieser "Interrupt- Stack" jedesmal DERSELBE (nicht 
nur  der gleich,  sondern tats√§chlich derselbe).  TOS  1.2  beispielsweise 
setzt den ssp immer auf $755a beim Start eines Prozesses.
Beim Aktivieren des ACC geschieht folgendes:

- Die  Hauptapplikation  ruft AES  auf  (evnt...);  R√ºcksprungadresse  und 
  geretteter SR liegen auf dem Supervisorstack der Hauptapplikation.
- Der  Kontextwechsel (Umschalten aller Register einschlie√ülich  ssp)  auf 
  das ACC findet statt.
- Das ACC l√§uft.  ACCs haben einen eigenen Supervisor- Stack,  der von AES 
  angelegt  wird,  bevor  das  ACC (nicht √ºber  Pexec()!)  das  erste  Mal 
  gestartet wird.
- Wird nun ein neuer Proze√ü gestartet,  legt GEMDOS denselben  Supervisor- 
  Stack an,  wie ihn die Haupapplikation hat.  Beim ersten Interrupt  oder 
  DOS- Aufruf werden R√ºcksprungadresse und geretteter SR zerst√∂rt.
  Soll  nun  die  Hauptapplikation  wieder  gestartet  werden,  liegt  die 
  R√ºcksprungadresse nicht mehr auf dem Stack. Das System st√ºrzt ab.

Der Fehler tritt im Desktop nicht auf, da DESKTOP einen eigenen Interrupt- 
Stack hat und st√§ndig im Supervisormodus l√§uft.
Der Fehler ist offensichtlich gleichzeitig AES und GEMDOS anzulasten.  Man 
kann  auch sagen,  da√ü das Starten von Prozessen von einem  Accessory  aus 
einfach nicht erlaubt ist.

Die  Korrektur:  KCMD.ACC wei√ü von TOS 1.0,1.2,1.4 (vom  6.4.89),  welchen 
Default- Supervisor- Stack GEMDOS f√ºr neue Prozesse anlegt.  Es fragt  die 
TOS- Versionsnummer ab und merkt sich diesen Default- SSP.

Wird  das ACC aktiviert,  werden die obersten 20 Langworte  dieses  Stacks 
gesichert  (sicherheitshalber,  es m√º√üten eigentlich die obersten 3  Worte 
gen√ºgen).  Wird  dieser  Stack zerst√∂rt,  macht das  nichts,  da  vor  dem 
n√§chsten  AES-  Aufruf  (zur  R√ºckkehr in  die  Hauptapplikation)  die  20 
Langworte wieder zur√ºckgeschrieben werden.  Bisher hat sich diese Ma√ünahme 
als  ausreichend  erwiesen.   Trotzdem  k√∂nnten  im  Einzelfall   Probleme 
auftreten.  Man sollte vorher immer testen,  ob der Aufruf von  Programmen 
funktioniert, bevor man wichtige Daten aufs Spiel setzt.
