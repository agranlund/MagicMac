Mag!X 2.0 Programmers Guide
---------------------------

Was kann Mag!X und was [noch] nicht?
------------------------------------

Mag!X ist ein Multitaskingsystem, das seit der Version 2.0 mit prÑemptivem
Multitasking arbeitet, ein weitgehend MultiTOS-kompatibles AES und ein
Mehrprozeû-DOS enthÑlt.
Mag!X arbeitet (zur Zeit) nicht mit MiNT zusammen - was aber nicht bedeuten
muû, daû Åberhaupt keine MiNT-kompatiblen Funktionen unter Mag!X zur VerfÅgung
stehen werden!!


Wie erkenne ich Mag!X?
----------------------

Mag!X legt einen Cookie mit der Kennung 'MagX' an. Der Cookie enthÑlt als
Wert einen Zeiger auf folgende Struktur (-> MAGX.H):

   typedef struct
   {
      long    config_status;
      DOSVARS *dosvars;
      AESVARS *aesvars;
   } MAGX_COOKIE;

- <config_status> ist der Konfigurations- Bitvektor, der durch das
  Konfigurationsmodul MAGXCONF.[CPX/ACC] verÑndert wird.

- <dosvars> ist ein Zeiger auf die  DOSVARS-Struktur
   typedef struct
      {
         char      *in_dos;                 /* Adresse der DOS- Semaphore */
         int       *dos_time;               /* Adresse der DOS- Zeit      */
         int       *dos_date;               /* Adresse des DOS- Datums    */
         long      res1;                    /*                            */
         long      res2;                    /*                            */
         long      res3;                    /* ist 0L                     */
         void      *act_pd;                 /* Laufendes Programm         */
         long      res4;                    /*                            */
         int       res5;                    /*                            */
         void      res6;                    /*                            */
         void      res7;                    /* interne DOS- Speicherliste */
         void      (*resv_intmem)();        /* DOS- Speicher erweitern    */
         long      (*etv_critic)();         /* etv_critic des GEMDOS      */
         char *    ((*err_to_str)(char e)); /* Umrechnung Code->Klartext  */
         long      res8;                    /*                            */
         long      res9;                    /*                            */
         long      res10;                   /*                            */
      } DOSVARS;

   Diese Variablen sind READ-ONLY!

- <aesvars> zeigt auf die AESVARS- Struktur

   typedef struct
     {
        long magic;                   /* muû $87654321 sein            */
        void *membot;                 /* Ende der AES- Variablen       */
        void *aes_start;              /* Startadresse                  */
        long magic2;                  /* ist 'MAGX'                    */
        long date;                    /* Erstelldatum ttmmjjjj         */
        void (*chgres)(int res, int txt);  /* Auflîsung Ñndern         */
        long (**shel_vector)(void);   /* residentes Desktop            */
        char *aes_bootdrv;            /* von hieraus wurde gebootet    */
        int  *vdi_device;             /* vom AES benutzter VDI-Treiber */
        void *reservd1;
        void *reservd2;
        void *reservd3;
        int  version;
        int  release;
     } AESVARS;

   Diese Variablen sind READ-ONLY!

Die ersten drei Variablen sind Åbrigens auch im TOS vorhanden und kînnen dort
Åber den Betriebssystem- Header ermittelt werden.
vdi_device ist ab Mag!X 2.0 ÅberflÅssig, weil man die GerÑtenummer MultiTOS-
kompatibel Åber appl_getinfo() erhÑlt.
Wichtig ist hierbei, daû die Variable <aesvars> erst  beim Start von
Mag!X-AES installiert wird und vorher NULL ist. Kein Programm, das Mag!X-
spezifische AES-Aufrufe benutzt, sollte dies tun, bevor sowohl die Existenz
des Cookies sichergestellt wurde als auch der Wert der Variablen <aesvars>
als gÅltig, d.h. ungleich NULL, erkannt wurde.

Zum Test auf Mag!X und die Mag!X-Versionsnummer wird folgende Routine
empfohlen:

/*-------------------------------------------------------------------------*/
/* InqMagX()                                                               */
/*                                                                         */
/* Liefert                                                                 */
/*  -1:   Kein Mag!X vorhanden                                             */
/*  -2:   Mag!X installiert, aber Mag!X-AES inaktiv; d.h. Mag!X wird nur   */
/*        als schnelles Dateisystem benutzt!                               */
/*  >0:   Mag!X vorhanden und Mag!X-AES aktiv. Der RÅckgabewert enthÑlt    */
/*        die BCD-codierte Versionsnummer.                                 */
/*-------------------------------------------------------------------------*/

#include "magx.h"

WORD  InqMagX(void)
{
   MAGX_COOKIE  *cv;

   if( getcookie('MagX',(LONG *)&cv) ){
      if( cv->aesvars ){
         return(cv->aesvars->version);
      }
      else return(-2);
   }
   else  return(-1);
}

Arbeitet mein Programm in einem Multitaskingsystem?
---------------------------------------------------
Um das festzustellen, genÅgt es die maximale Anzahl der parallel laufenden
Applikationen zu ermitteln. Diese findet sich in sÑmtlichen GEM-Versionen
im global[1]  (auch als <ap_count> bezeichnet). Bei Singletasking-TOS steht
hier ein 1. Alles andere bedeutet: Es liegt ein Multitaskingsystem vor;
steht hier -1 gibt es keine BeschrÑnkung (au·er durch den vorhandenen
Speicher).


AES allgemein
-------------
Die FunktionalitÑt des Mag!X-AES wurde in Version 2.0 soweit mîglich (und
sinnvoll) an MultiTOS angenÑhert. Welche Funktionen implementiert wurden,
kînnen Sie mit Hilfe der erweiterten appl_getinfo()-Funktion gezielt
ermitteln. Die Funktion steht in dieser (erweiterten) Form auch ab MultiTOS
Rev. 1.07 zur VerfÅgung!

MTOS-kompatible AES-Funktionen in Mag!X 2.0
-------------------------------------------

APPL_FIND
---------
Diese   Funktion  ermittelt  im  GEM  die  ID  der  mit  <pname>  Åbergebenen
Applikation.  In  Mag!X und MultiTOS kann man zusÑtzlich durch öbergabe eines
Nullpointers  die  ID  der  aktuellen  Applikation  ermitteln (ist eigentlich
unnîtig,  da  diese  in  global[2]  unter  allen TOS- Versionen zur VerfÅgung
steht, aber eben in MultiTOS so dokumentiert ...).
Die  in  MultiTOS  eingebauten zusÑtzlichen Modi zur Umsetzung der PID in die
Applikations-ID  sind in Mag!X 2.0 nicht vorhanden. Sobald Dlock() eingebaut
ist,  wird  diese  Funktion  jedoch  zur  VerfÅgung stehen. Das Vorhandensein
dieses Features ist Åber appl_getinfo() nachprÅfbar.

Deklaration:

   int appl_find(const char *pname);

   Parameter:
        contrl[0] = 13
        contrl[1] = 0
        contrl[2] = 1
        contrl[3] = 1
        contrl[4] = 0

        int_out[0] = ap_id
        addr_in[0] = pname

   Bedeutung von <ap_id>

       -1: falls das AES die angegebene Applikation nicht finden konnte
    sonst: ID

   Bedeutung von <pname>

      Dateiname der zu suchenden Applikation (ohne Extension). Der
      nullterminierte String muû aus 8 Zeichen bestehen - ggf. mit
      Leerzeichen auffÅllen.
      Wird ein Nullpointer Åbergeben, so wird die ID der aktuellen
      Applikation ermittelt.


APPL_READ
---------
Diese  Funktion  liest eine bestimmte Anzahl von Bytes aus der "message pipe"
des  AES.  Die  Funktion  wartet  ggf.,  bis  die  angeforderte  Anzahl Bytes
tatsÑchlich  zur  VerfÅgung stehen. In Mag!X und MultiTOS ist die Funktion so
erweitert  worden, daû sie mit einer entsprechenden Meldung zurÅckkehrt, wenn
keine Daten vorhanden sind.

Deklaration:

   int appl_read(int rwid, int length, void *pbuff);

   Parameter:
        contrl[0] = 11
        contrl[1] = 2
        contrl[2] = 1
        contrl[3] = 1
        contrl[4] = 0

        int_in[0]  = rwid
        int_in[1]  = length
        int_out[0] = ap_rreturn     0: Fehler
        addr_in[0] = pbuff


   Bedeutung von <rwid>
        -1: Lies "message pipe" nur aus, wenn Daten vorhanden sind. Andernfalls
            kehre sofort zurÅck
     sonst: ap_id der [eigenen!] Applikation

   Bedeutung von <length>
      Anzahl der zu lesenden Bytes

   Bedeutung von <pbuff>
      Puffer, in dem die einzulesenden Bytes abgelegt werden sollen


APPL_SEARCH
------------
Diese Funktion sucht in Mag!X und MultiTOS alle im System vorhanden
Applikationen.

Deklaration:
   int   appl_search( int ap_smode, char *ap_sname, int *ap_stype,
                      int *ap_sid );

    Parameter:
        contrl[0] = 18
        contrl[1] = 1
        contrl[2] = 3
        contrl[3] = 1
        contrl[4] = 0

        int_in[0]     = ap_smode
        addr_in[0]    = ap_sname
        int_out[0]    = ap_sreturn
        int_out[1]    = ap_stype
        int_out[2]    = ap_sid

   Bedeutung von <ap_smode>
      0: Suche erste App.
      1: Suche nÑchste App.
      2: Suche die System Shell

   Bedeutung von <ap_sname>
      Puffer, der den Namen der gefunden Applikation aufnimmt. Mindestgrîûe
      9 Bytes!

   Bedeutung von <ap_stype>
      1: System-Prozeû
      2: Applikation
      4: Accessory

   Bedeutung von <ap_sid>
      Applikations-ID

   Bedeutung von <ap_sreturn>
      0: keine weiteren Applikationen vorhanden
      1: kein Fehler

- appl_getinfo() s.u.



GRAF_MOUSE
----------
In  Mag!X  und  Multitos  werden  die Mauszeiger applikationslokal verwaltet.
Neben  den  im  TOS vorhandenen graf_mouse()-Opcodes stehen die Codes 258,259
und  260  zur  VerfÅgung,  die  z.B. von neueren XCONTROL-Versionen verwendet
werden.

   Bedeutung der neuen Opcodes:

      258 - Sichere aktuelle Mausform
      259 - Stelle die zuletzt gesicherte Mausform wieder her
      260 - Stelle die vorherige Mausform wieder her



OBJC_SYSVAR
-----------
MultiTOS  bietet  zur  Modifikation der 3D-Objekte die Funktion objc_sysvar()
an.  Diese  Funktion  ist  in Mag!X ebenfalls vorhanden, lÑût aufgrund der in
Mag!X  2.00  noch  fehlenden 3D-Objekte allerdings keine Modifikationen zu ->
RÅckgabewert von objc_sysvar() beachten!!


MENU_BAR
--------
Diese  Funktion  zeichnet  oder  lîscht  die MenÅzeile. In Mag!X und MultiTOS
kann man zusÑtzlich den Eigner der MenÅleiste erfragen.

Deklaration:
   int menu_bar( OBJECT *me_btree, int me_bshow );

     Parameter:
        contrl[0] = 30
        contrl[1] = 1
        contrl[2] = 1
        contrl[3] = 1
        contrl[4] = 0

        int_in[0]  = me_bshow
        int_out[0] = me_breturn
        addr_in[0] = me_btree

   Bedeutung von  <me_bshow>
       0:   Lîsche MenÅzeile
       1:   Zeichne MenÅzeile
      -1:   menu_bar() ermittelt die ID des Eigners der MenÅzeile. Wenn der
            RÅckgabewert <me_breturn> -1 ist, so gibt es keinen Eigner.
            Da die MenÅzeile laufend wechseln kann, muû zur sicheren Abfrage
            der Bildschirm per wind_update gesperrt werden.

            Beispiel:


            wind_update(1);     

            id = menu_bar( 0x0L, -1 );

            if ( id == my_id )
            {
                 /* update the menu and draw it */
            }
            else
            {
               /* update the menu but don't draw it */
            }

            wind_update(0);


RSRC_RCFIX
----------
Diese  in  Mag!X  und  Multitos  vorhanden  Funktion paût von der Applikation
bereits   in  den  Speicher  geladene  Resourcedaten  an.  Dabei  werden  die
Koordinaten vom Zeichen- in Pixelkoordinaten umgewandelt.
Falls  die  Applikation vor dem Aufruf dieser Funktion bereits eine RSC-Datei
geladen  hat,  so muû diese vorher mit rsrc_free() freigegeben werden. Ebenso
muû beim Beenden der Applikation rsrc_free() aufgerufen werden.

Also:

     rsrc_load("dateiname")

ist gleichbedeutend mit

     "dateiname" einlesen (per Fopen/Fread)
     rsrc_rcfix()

Der  Vorteil  der  zweiten  Vorgehensweise  ist,  daû  man,  statt  die Datei
einzulesen,  diese  bereits  in  der  PRG- Datei integrieren kann und einfach
rsrc_rcfix() aufruft.

Deklaration:

   int   rsrc_rcfix(RSHDR *rc_header);

   Parameter:
        contrl[0] = 115
        contrl[1] = 0
        contrl[2] = 1
        contrl[3] = 1
        contrl[4] = 0

        int_out[0] = rc_return
        addr_in[0] = rc_header

   Bedeutung von <rc_header>
      Die Adresse des RSC-Header im Speicher - hinter diesem mÅssen die RSC-
      Daten liegen.

SHEL_GET
--------
Diese  Funktion  dient  zum Einlesen von Zeichen aus dem sogenannten internen
AES-  Environment-Speicher.  Unter Mag!X und MultiTOS kann man zusÑtzlich die
LÑnge dieses Speichers ermitteln.
Es  handelt sich nicht tatsÑchlich um das Environment (das Variablen wie PATH
enthÑlt),  sondern  um  den  Puffer, der im alten TOS das DESKTOP.INF mit den
Kontrollfelddaten  enthielt. Unter Mag!X werden beim Start des AES alle Daten
in den Puffer kopiert, die nach der Zeile #_CTR in MAGX.INF liegen.

Deklaration:

   int shel_get( char *sh_gaddr, int sh_glen );

   Parameter:
     contrl(0) = 122
     contrl(1) = 1
     contrl(2) = 1
     contrl(3) = 1
     contrl(4) = 0

     int_in(0)  = sh_glen
     addr_in(0) = sh_gaddr
     int_out(0) = sh_greturn     0: Fehler

   Bedeutung von <sh_glen>
      -1:   <sh_greturn> liefert die Grîûe des internen Speichers zurÅck
   sonst:   Anzahl der zu lesenden Bytes

   Bedeutung von <sh_gaddr>
      Anfangsadresse des Zielspeichers


WIND_GET
--------
Liefert je nach Unterfunktion verschiedene Informationen Åber ein Fenster.

Deklaration:

  int wind_get( int w_handle, int w_field, int *pw1, int *pw2,
                int *pw3, int *pw4);

  Parameter:
        contrl[0] = 104
        contrl[1] = 2
        contrl[2] = 5
        contrl[3] = 0
        contrl[4] = 0

        int_in[0]  = w_handle
        int_in[1]  = w_field
        int_out[0] = Return-Wert (0: Fehler)
        int_out[1] = pw1
        int_out[2] = pw2
        int_out[3] = pw3
        int_out[4] = pw4

   Bedeutung von <w_handle>
      Kennung des betreffenden Fensters

   Bedeutung von <w_field>
      GewÅnschte Information. Die Inhalte von pw1 ... pw4 hÑngen ab von:

Folgende Erweiterungen sind in Mag!X und MultiTOS vorhanden:

WF_TOP (10):
   pw1: topwin          ;Kennung des obersten Fensters
   pw2: topowner        ;App-Id des Eigners
   pw3: belowwin        ;nÑchstes Fenster
   pw4: topwin          ;nur unter Mag!X

  Liefert die Kennung des obersten Fensters, des nÑchsten Fensters (das
  nÑchste Fenster des Desktop-Hintergrund ist -1!) und die App-Id des
  Eigners des obersten Fensters im Fensterstapel.
  Ist kein Fenster offen, enthÑlt topwin 0.

  Achtung:  Mag!X muû als oberstes Fensterhandle eine negative Zahl (-2)
            liefern, falls das Programm einer anderen Applikation gehîrt,
            sonst laufen eine Reihe alter Programme nicht (->Tempus u.v.a.m).
            Ab Mag!X 2.0 wird das tatsÑchliche Handle in pw4 zurÅckgeliefert.

  Hinweis:  Eine einzelne Applikation sollte unter Mag!X 2.0 nicht mehr als
            16 Fenster nutzen, da sonst der Nachrichtenpuffer des Systems
            Åberlaufen kann und evtl. Redraws nicht mehr ausgefÅhrt werden
            kînnen.

WF_NEWDESK (14)
   pw1: hi
   pw2: lo
   pw3: firstob      ;nur unter Mag!X

   Liefert die Adresse (hi/lo) des aktiven Desktop-Hintergrunds und (unter
   Mag!X) zusÑtzliche die Objektnummer.

WF_OWNER (20):
   pw1: owner           ;App-Id des Eigners
   pw2: isopen          ;geîffnet (1) oder geschlossen (0)
   pw3: abovewin        ;Kennung des darÅber liegenden Fensters
   pw4: belowwin        ;Kennung des darunter liegenden Fensters

  Liefert Informationen Åber ein Fenster. Das Fenster kann auch
  geschlossen sein (d.h. es ist nicht im Fensterstapel), bzw.
  gar nicht existieren (dann liefert die Funktion 0).

WF_BEVENT (24):
   pw1: bstate

  Liefert den BEVENT-Status des Fensters im Bit 0 von <bstate>.



WF_DCOLOR (19):
   pw1: Fensterelement
   pw2: Farbe des aktiven Fensters
   pw3: Farbe des inaktiven Fensters

   Die Funktion liefert die Fensterfarben (wird z.B. von dem CPX-Modul
   WCOLOR verwendet).



WIND_SET
--------
Je nach Unterfunktion werden verschiedene Fenstereigenschaften verÑndert

Deklaration:

  int wind_set( int w_handle, int w_field, int w1, int w2, int w3, int w4);

  Parameter:
        contrl[0] = 105
        contrl[1] = 6
        contrl[2] = 1
        contrl[3] = 0
        contrl[4] = 0

        int_in[0] = w_handle
        int_in[1] = w_field
        int_in[2] = w1
        int_in[3] = w2
        int_in[4] = w3
        int_in[5] = w4
        int_out[0] = Return-Wert (0: Fehler)


   Bedeutung von <w_handle>
      Kennung des betreffenden Fensters

   Bedeutung von <w_field>
      Unterfunktionsnummer; w1 ... w4 werden in AbhÑngigkeit davon
      interpretiert

Folgende Erweiterungen sind in Mag!X und MultiTOS vorhanden:

WF_DCOLOR (19):
   w1: Fensterelement
   w2: Farbe fÅr aktive Fenster
   w3: Farbe fÅr inaktive Fenster

   Die Funktion Ñndert die Fensterfarben (wird z.B. von dem CPX-Modul
   WCOLOR verwendet).

   Achtung: Die Unterfunktion WF_COLOR (18), die einem bestimmten Fenster
            eine eigene Farbgebung ermîglicht, wird nicht unterstÅtzt. Die
            Funktion belegt eine bereits durch GEM/2 definierte Funktion
            (WF_TATTRB) und der Nutzen dieses Features ist mehr als
            fragwÅrdig.
            Wird die Fensterfarbe nicht beim Booten, sondern spÑter von Hand
            umgeschaltet, sollte ein AufrÑumen des Bildschirms durchgefÅhrt
            werden.

WF_BEVENT (24):
   w1: bstate     ;1: WF_BEVENT aktiv, 0: inaktiv

   WF_BEVENT sorgt dafÅr, daû der Besitzer des Fensters beim Klick
   in das Fensterinnere keine WM_TOPPED-Nachricht erhÑlt, wenn das
   Fenster nicht aktiv ist. Stattdessen wird ein MU_BUTTON aus-
   gelîst, falls der Besitzer eine entsprechende Anforderung bei
   evnt_multi() gestellt hat.

WF_BOTTOM (25):
   WF_BOTTOM stellt ein Fenster im Fensterstapel nach hinten. Das
   Fenster muû offen sein!


WIND_UPDATE
-----------
Mag!X implementiert den 'check and set mode' von AES 4.0, der durch ein
gesetztes Bit 8 (also BEG_UPDATE | 0x100 bzw. BEG_MCTRL | 0x100) aktiviert
wird.
In diesem Modus wird die Update-Kontrolle nur noch Åbernommen, falls keine
andere Applikation die Kontrolle hat oder die eigene Applikation die
Update-Kontrolle besitzt.
Kann die Applikation die Kontrolle nicht Åbernehmen, liefert die Funktion
den Wert 0.


Nachrichten
-----------
WM_UNTOPPED (30):
WM_ONTOP (31):

Diese Meldungen werden dazu benutzt, um Applikationen Åber eine VerÑnderung
des aktiven Fensters zu informieren. WM_UNTOPPED wird nach dem ôffnen bzw.
Aktivieren eines Fensters an den Besitzer des vorher aktiven Fensters
geschickt. WM_ONTOP wird nach dem Schlieûen bzw. Deaktivieren des aktiven
Fensters an den Besitzer des danach aktiven Fensters geschickt. Zum
Zeitpunkt der Ankunft der Nachricht kann sich der Fensterstapel bereits
wieder verÑndert haben. Beide Funktionen liefern in mbuf[3] die
Fensterkennung.

Achtung: Nach MultiTOS- Spezifikation werden die Nachrichten nur
         verschickt, wenn die Applikation nicht mit einem Aufruf das
         Fenster selbst in den Vordergrund/Hintergrund gelegt hat.
         Die Nachrichten WM_ONTOP werden im Nachrichtenpuffer des AES
         verschmolzen, damit wird immer die letzte Nachricht empfangen, es
         kînnen sich nicht mehrere im Puffer befinden.

WM_BOTTOMED (33):

Mit dieser Nachricht wird fordert der SCREENMANAGER die Applikation auf,
das spezifizierte Fenster mit wind_set( win, WF_BOTTOM, 0,0,0,0) nach
hinten zu stellen.

Hinweis: Diese Nachricht war beim Erscheinen von Mag!X 2.0 in der
         offiziellen MTOS-Version 1.01 noch nicht implementiert. Mag!X 2.0
         sendet daher zur Zeit [noch] die (Mag!X-spezifische) WM_M_BDROPPED
         (100)-Nachricht. ZukÅnftigen Mag!X-Versionen werden die
         inzwischen in MTOS ·-Versionen eingefÅhrte WM_BOTTOMED-Message
         unterstÅtzen.


SH_WDRAW (72):

Mit dieser Nachricht informiert eine Applikation die Shell, da· sich der
Inhalt eines Laufwerks geÑndert hat und die Fenster der Shell zu
aktualisieren sind.
Die Laufwerksnummer wird in mbuf[3] spezifiziert; 0 fÅr Laufwerk A:, 1 fÅr
Laufwerk B:, etc.. Wird in mbuf[3] -1 eingetragen, so aktualisiert die
Shell alle Fenster.
Diese Nachricht wird von MAGXDESK und auch von EASE 3 und GEMINI 2
unterstÅtzt.

CH_EXIT (90):

Die Nachricht wird an den Parent-Proze· geschickt, wenn das (per
shel_write) gestartete Child beendet wird.
mbuf[3] enthÑlt die App-Id des Child; mbuf[4] den RÅckgabewert ("exit
code").


Mag!X-spezifische Nachrichten
-----------------------------
WM_M_BDROPPED (100):

Da die noch aus Mag!X 1.0 stammende Nachricht WM_BACKDROPPED leider mit
WM_ONTOP (MultiTOS) identisch war, wurden die Mag!X-spezifischen
Nachrichten ab Mag!X 2.0 auf Codes >= 100 gelegt und in MAGX.H mit XX_M_YY
definiert.
Statt WM_BACKDROPPED (31) gibt es jetzt WM_M_BDROPPED (100). Diese
Nachricht erhÑlt eine Applikation, wenn Sie beim wind_create() das
Fensterobjekt BACKDROP (0x2000) angemeldet hat und der Backdrop-Button
betÑtigt wurde. Die Applikation kann dann das Fenster per wind_set(whdl,
WF_BOTTOM) selbst in den Hintergrund legen oder anderweitig sinnvoll
reagieren.

Wird das Bit BACKDROP bei wind_create() nicht gesetzt, Åbernimmt Mag!X in
eigener Regie die vollstÑndige Behandlung des Backdrop- Buttons. Dies gilt
insbesondere fÅr jegliche Ñltere Software, die so ebenfalls vom Backdrop-
Button profitieren kann. In diesem Fall schickt das AES die Nachricht
WM_TOPPED an das nÑchste Fenster, worauf das Programm mit wind_set(WF_TOP)
reagieren kann. Statt das zweite Fenster nach oben zu bringen, schickt AES
das oberste nach unten, womit das zweite nach oben kommt. Reagiert das
Programm nicht auf die WM_TOPPED-Nachricht (weil z.B. ein Dialog erst
beendet werden soll), so unterbleibt das Backdroppen.
Mit der Funktion appl_getinfo() ist abfragbar, ob ein expliziter
BACKDROP-Button vom AES unterstÅtzt wird.

... und wie kann ich erkennen, welche Funktionen zur VerfÅgung stehen?
----------------------------------------------------------------------
(appl_getinfo)

Seit  geraumer  Zeit  (AES  Version 4.0, also auch im MultiTOS 1.0) existiert
die  AES-  Funktion  appl_getinfo(),  die  seit  MultiTOS 1.07· (AES V4.01) in
neuen   Unterfunktionen   (ab  Funktionsnummer  4)  auch  Informationen  Åber
vorhandene  Funktionsaufrufe  und Eigenschaften sowohl von Mag!X als auch von
MultiTOS liefert.
Mit  Hilfe dieser in Mag!X 2.0 und MultiTOS vorhandenen Funktion lassen sich
gezielt   Eigenschaften   beider   Systeme   auch   zur   Laufzeit  erfragen.
Gewissermaûen  ist  dies  die  Absegnung  der neuen Mag!X- Funktionen seitens
Atari.  Ferner  werden wir uns bemÅhen, zukÅnftige Erweiterungen beiderseitig
abzustimmen,   um   UnvertrÑglichkeiten   zwischen   Mag!X  und  MultiTOS  zu
verhindern.
FÅr  den  Fall,  daû  die  GEM-Bibliothek  Ihres Compilers diesen Aufruf noch
nicht  unterstÅtzt, folgt hier der Aufruf und die Definition dieser Funktion.
Man Åbergibt eine Unterfunktionsnummer und erhÑlt 4 RÅckgabewerte:

   ap_greturn = appl_getinfo( ap_gtype, &ap_gout1, &ap_gout2,
                              &ap_gout3, &ap_gout4 );

  Die Parameter sind:
     control[0] = 130;
     control[1] = 1;
     control[2] = 5;
     control[3] = 0;
     control[4] = 0;

     int_in[0]     = ap_gtype;      /* Unterfunktionsnummer */
     int_out[0]    = ap_greturn;    /* RÅckgabewert   */
     int_out[1]    = ap_gout1;      /* Wort 1   */
     int_out[2]    = ap_gout2;      /* Wort 2   */
     int_out[3]    = ap_gout3;      /* Wort 3   */
     int_out[4]    = ap_gout4;      /* Wort 4   */

  <ap_greturn> zeigt ggf. Fehler an:
      0 - Fehler
      1 - Kein Fehler


  Es gibt folgende Unterfunktionen; sie sind auch unter Mag!X vorhanden:

  Funktion 0: Informationen Åber den normalen AES- Zeichensatz
  -> Wort 1    Fonthîhe
     Wort 2    Font-ID
     Wort 3    Font-Typ (0=system,1=FSM)

  Funktion 1: dito fÅr den kleinen Zeichensatz

  Funktion 2: Farben
  -> Wort 1    VDI-GerÑtenummer (device id)
     Wort 2    Farben fÅr OBJECTs
     Wort 3    Farbicons vorhanden (1) bzw. nicht (0)
     Wort 4    neues RSC-Format vorhanden (1) oder nicht (0)

  Funktion 3: Sprache
  -> Wort 1    0 - Englisch
               1 - Deutsch
               2 - Franzîsisch
               3 - reserviert
               4 - Spanisch
               5 - Italienisch
               6 - Schwedisch

  Funktion 4: allgemeine Information Nr. 1
  -> Wort 1    Multitasking prÑemptiv (1) oder nicht (0)
     Wort 2    appl_find konvertiert MiNT und AES-IDs (1) oder nicht (0)
     Wort 3    appl_search vorhanden (1) oder nicht (0)
     Wort 4    rsrc_rcfix vorhanden (1) oder nicht (0)

  Funktion 5: allgemeine Information Nr. 2
  -> Wort 1    objc_xfind vorhanden (1) oder nicht (0)
     Wort 2    reserviert, immer 0
     Wort 3    menu_click (GEM/3 + Mag!X) vorhanden (1) oder nicht (0)
     Wort 4    shel_r/wdef (GEM/3 + Mag!X) vorhanden (1) oder nicht (0)

  Funktion 6: allgemeine Information Nr. 3
  -> Wort 1    appl_read(-1) vorhanden (1) oder nicht (0)
     Wort 2    shel_get(-1) vorhanden (1) oder nicht (0)
     Wort 3    menu_bar(-1) vorhanden (1) oder nicht (0)
     Wort 4    menu_bar(MENU_INSTL) (Mag!X) vorhanden (1) oder nicht (0)

  Funktion 7: reserviert fÅr Mag!X und andere Erweiterungen, MultiTOS setzt
              alle RÅckgabewerte immer auf 0

  Funktion 8: Maus
  -> Wort 1    graf_mouse- Modi 258-260 vorhanden (1) oder nicht (0)
     Wort 2    Mausform vom AES fÅr jede App. verwaltet (1) oder nicht (0)

  Funktion 9: MenÅs
  -> Wort 1    MultiTOS-SubmenÅs vorhanden (1) oder nicht (0)
     Wort 2    MultiTOS-Popups vorhanden (1) oder nicht (0)
     Wort 3    MultiTOS-ScrollmenÅs vorhanden (1) oder nicht (0)
     Wort 4    erweiterte MN_SELECTED- Nachricht vorhanden (1) oder nicht (0)

  Funktion 10: shel_write
  -> Wort 1    vorhandene Modi
               Bit 0..7:  hîchster zulÑssiger Wert fÅr sh_wdoex & 0x00ff
               Bit 8..15: Bits von sh_wdoex & 0xff00, die wie in MultiTOS
                          behandelt werden
     Wort 2    1: shel_write(0) macht vorherige shel_write- Aufrufe ungÅltig
                  (d.h. das Desktop wird Nachfolgeprogramm) (TOS 1.4 &
                   Mag!X)
               0: startet Programm (MultiTOS)
     Wort 3    1: shel_write(1) startet Programm nach Beendigung des
                  laufenden (TOS 1.4 & Mag!X)
               0: startet Programm sofort (MultiTOS)
     Wort 4    ARGV via sh_wiscr unterstÅtzt (1) oder nicht (0)

  Funktion 11: Fenster
  -> Wort 1    gesetzte Bits signalisieren unterstÅtzte Funktionen:
               Bit 0: WF_TOP liefert zweitoberstes Fenster
                   1: wind_get(WF_NEWDESK)
                   2: wind_g/set(WF_COLOR)
                   3: wind_g/set(WF_DCOLOR)
                   4: wind_get(WF_OWNER)
                   5: wind_g/set(WF_BEVENT)
                   6: WF_BOTTOM
                   7: WF_ICONIFY
                   8: WF_UNICONIFY
                   9..15: reserviert, immer 0
     Wort 2    reserviert, 0
     Wort 3    vorhandene Fensterbuttons:
               Bit 0: Iconifier
                   1: Backdrop-Button (Mag!X)
                   2: Shift-Click fÅr Backdrop
                   3: "Hot" Closebox (GEM/3 & Mag!X)
                   4..15: reserviert, 0
     Wort 4    wind_update check_and_set vorhanden (1) oder nicht (0)

  Funktion 12: Nachrichten
  -> Wort 1    gesetzte Bits signalisieren unterstÅtzte Nachrichten:
               Bit 0: WM_NEWTOP
                   1: WM_UNTOPPED
                   2: WM_ONTOP
                   3: AP_TERM
                   4: MultiTOS- Auflîsungswechsel
                   5: CH_EXIT
                   6: WM_BOTTOM
                   7: WM_ICONIFY
                   8: WM_UNICONIFY
                   9: WM_ALLICONIFY
     Wort 2    reserviert, alle 0
     Wort 3    WM_ICONIFY liefert Koordinaten (1) oder nicht (0)

  Funktion 13: OBJECTs
  -> Wort 1    3D- Objekte Åber ob_flags vorhanden (1) oder nicht (0)
     Wort 2    objc_sysvar vorhanden (1) oder nicht (0)


     Wort 3    Speedo- und GDOS- Fonts im TEDINFO erlaubt (1) oder nicht (0)
     Wort 4    reserviert fÅr Mag!X, wird von MultiTOS auf 0 gesetzt
               Bit 0: G_SWBUTTON vorhanden
                   1: G_POPUP vorhanden
                   2: WHITEBAK steuert Unterstriche und Buttons

  Funktion 14: Formulare (Mag!X form_xdo und form_xdial)
  -> Wort 1    Mag!X- Flydials vorhanden (1) oder nicht (0)
     Wort 2    Mag!X- Tastaturtabellen vorhanden (1) oder nicht (0)
     Wort 3    letzte Cursorposition wird zurÅckgegeben (1) oder nicht (0)
     Wort 4    reserviert, 0


GEM/2- und GEM/3-kompatible Funktionen in Mag!X
-----------------------------------------------

Mag!X unterstÅtzt folgende GEM/2- bzw. GEM/3-Funktionen:

void appl_yield     ( void );                               /* GEM 2.x     */
int  menu_click     ( int val, int setit );                 /* GEM 3.x     */
void shel_rdef      ( char *cmd, char *dir );               /* GEM 2.x     */
void shel_wdef      ( char *cmd, char *dir );               /* GEM 2.x     */
int  menu_unregister( int menu_id );                        /* GEM 2.x     */
int  scrp_clear     ( void );                               /* GEM 2.x     */
int  xgrf_stepcalc  (                                       /* GEM 2.x     */
                      int orgw, int orgh, int xc, int yc, int w, int h,
                      int *cx, int *cy, int *stepcnt, int *xstep, int *ystep
                    );
int  xgrf_2box      (                                       /* GEM 2.x     */
                      int xc, int yc, int w, int h,int corners, int stepcnt,
                      int xstep, int ystep, int doubled
                    );

und als Fensterelement:

#define HOTCLOSEBOX      0x1000                             /* GEM 2.x     */

Die Bedeutung der einzelnen Funktionen entnehmen Sie bitte der entsprechenden
GEM-Literatur. GegenÅber der GEM/2-Doku mu·ten aus KompatiblitÑtsgrÅnden zu
MultiTOS die Belegung von global[13] und global[14] geÑndert werden - sie ist
damit nicht mehr kompatibel zu GEM/2!
Die Funktionen-Nummern von xgrf_stepcalc() und xgrf_2box() sollten von
GEM-Programme nicht benutzt werden - sie sind nur aus GrÅnden der
AbwÑrtskompatiblitÑt fÅr Ñltere GEM/2-Programme implementiert.

Ein wenig erweitert wurde der Mechanismus zum Einbinden eines alternativen
Desktop:
Mit shel_wdef( char *cmd, char *dir ) legt man das alternative Desktop fest,
dasselbe tut auch der Parameter #_SHL in MAGX.INF. Sind <cmd> und <dir>
Leerstrings, ist MAGXDESK wieder installiert. Ein alternatives Desktop macht
zum  Programmstart einfach ein shel_write und beendet sich dann per Pterm0().
Ein alternatives Desktop bekommt von Mag!X folgende Kommandozeile, die
dieses Åber shel_read() ermitteln kann:

   typedef struct
        {
        int  dummy;                   /* ein Nullwort               */
        long magic;                   /* 'SHEL', wenn ist Shell     */
        int  isfirst;                 /* erster Aufruf der Shell    */
        long lasterr;                 /* letzter Fehler             */
        int  wasgr;                   /* Programm war Grafikapp.    */
        } SHELTAIL;

Gibt  die  Shell  einen negativen Fehlercode zurÅck, wird automatisch  wieder
MAGXDESK aktiviert.

Starten von Programmen
----------------------
Beim Start von Programmen aus einem eigenem Programm gibt es prinzipiell
zwei Mîglichkeiten:
Soll das eigene Programm verlassen werden, so Åbergibt man dem AES per
shel_write() Pfad und Parameter des zu startenden Programms und beendet
sich. Die andere Methode ist, das Programm als "Kind-Prozeû" direkt Åber
die DOS-Funktion Pexec() zu starten, was gewissermaûen am AES vorbei
geschieht und zu Schwierigkeiten fÅhren kann, da Programm und Parameter dem
AES nicht bekannt sind. Im Gegensatz zur Lîsung Åber shel_write() bleibt
hier das aufrufende Programm im Speicher, das neue wird wie ein
Unterprogramm aufgerufen, wÑhrend jenes solange angehalten wird.
Die sauberere Alternative ist zweifelsohne der shel_write()- Aufruf. Als
Unterfunktion gibt es hierbei den Paramter <isover> und <isgr (siehe dazu
einschlÑgige Literatur),  wobei <isover> folgende Werte annehmen kann (alle
in MAGX.H definiert):

#define SHW_IMMED        0                           /* PC-GEM 2.x  */
#define SHW_CHAIN        1                           /* TOS         */
#define SHW_DOS          2                           /* PC-GEM 2.x  */
#define SHW_PARALLEL     100                         /* MAG!X       */
#define SHW_SINGLE       101                         /* MAG!X       */

Unter TOS existiert nur die Unterfunktion SHW_CHAIN, man darf daher unter
Singletasking-TOS auf keinen Fall einen anderen Wert als 1 Åbergeben, auch
wenn Atari schon anderes behauptet hat. Die Unterfunktion  SHW_CHAIN
Åbernimmt einfach nur die Parameter und startet das  Programm  erst, wenn
das aktuelle beendet wurde; die Programme laufen also nacheinander ab. Nach
Beendigung des neuen Programms landet man wieder im Desktop, es sei denn,
dieses macht wiederum einen entsprechenden shel_write()- Aufruf.
Die Funktion SHW_IMMED startet unter PC-GEM 2.x oder 3.x das Programm
sofort, wÑhrend das laufende solange angehalten wird. Nach Beendigung des
neuen Programms lÑuft das alte weiter. Der Aufruf funktioniert wie ein
Pexec(), man benîtigt ihn daher eigentlich nicht.
SHW_DOS beendet auf dem PC das GEM vollstÑndig, um ein Programm zu starten,
das nicht unter GEM lÑuft und sehr viel Seicher benîtigt (das generelle PC-
Problem ...), Speicherprobleme gibt es auf dem Atari in der Form nicht,
also ist auch diese Unterfunktion uninteressant.

SHW_PARALLEL
------------
Unter Mag!X gibt es nun zusÑtzliche  Modi. Am wichtigsten ist SHW_PARALLEL,
der einfach eine neue Applikation startet; ab diesem Moment laufen der alte
und der neue Prozeû parallel. Die Funktion lieft die <ap_id> der
gestarteten Applikation zurÅck; wird diese beendet, so erhÑlt der Aufrufer
die Nachricht CH_EXIT.
Zur Unterscheidung von GEM- und TOS-Programmen (letztere werden ins Fenster
umgeleitet) dient der Parameter <isgr>. Der Wert 1 zeigt an, da· eine
GEM-Applikation gestartet werden soll, ein Wert 0 zeigt an, da· das
Programm keine Grafikapplikation (also ein TOS-Programm) ist.


SHW_SINGLE
----------
Der Modus SHW_SINGLE ist notwendig fÅr unsauber geschriebene Programme und
funktioniert wie der ganz normale Modus SHW_CHAIN, jedoch werden vor
Programmstart alle Applikationen auûer 0 (Hauptapplikation) und 1
(Bildschirmmanager) eingefroren und nach Programmende wieder aufgetaut; der
Aufruf ist (aus KompatibilitÑtsgrÅnden) _nur_ durch die Applikation 0
mîglich. Dieser Modus ist insofern nicht vollstÑndig kompatibel zum TOS,
als hierbei auch sÑmtliche Accessories gesperrt werden. Dies ist jedoch
nîtig, da unter Mag!X Fenster von Accessories beim Programmstart nicht
geschlossen werden und es meistens gerade die Fenster sind, die
unordentlich geschriebene Applikationen verwirren. Normalerweise kommen
Programme, die unter Mag!X nicht ordnungsgemÑû funktionieren und den
Single-Modus benîtigen, auch unter TOS nicht mit Accessories klar, so daû
diese Eigenschaft von Mag!X unkritisch ist.

Beachten Sie bitte, da· die genannten Erweiterungen von shel_write() in
dieser Form nur unter Mag!X zur VerfÅgung stehen. FÅr die neuen shelwrite-Modi
in MultiTOS wurde die Bedeutung der erwÑhnten Parameter z.T. stark
verÑndert.


Erweiterte GEM-Funktionen in Mag!X
----------------------------------
Zahlreiche GEM-Routinen wurden in Mag!X erweitert, mit neuen Features
versehen und auf den Multitaskingbetrieb angepa·t.
Dies betrifft unter anderem folgende Funktionen:

APPL_WRITE
----------
appl_write() erzeugt keinen öberlauf des Messagepuffers  mehr,  sondern
bricht mit RÅckgabewert 0 ab.  Bei falscher ap_id wird  RÅckgabewert -1
geliefert. RÅckgabe 1 zeigt erfolgreiche AusfÅhrung an.

MENU_BAR
--------
Die Funktion menu_bar() hat zusÑtzlich zu den Unterfunktionen MENU_SHOW (1)
und MENU_HIDE (0) eine weitere, MENU_INSTL (100) bekommenm. Hiermit kann
man z.B. als Accessory oder GEM-Auto-Programm ein MenÅ installieren, ohne
eine Umschaltung der obersten Applikation zu erzwingen. Alle Konstanten
sind in MAGX.H definiert.

SHEL_PUT
--------
shel_put() liefert 0 als RÅckgabewert, wenn der Puffer zu klein ist.

WIND_CREATE
-----------
Der in Mag!X hinzugekommene Backdrop-Button kann auch vom Programm aus
abgefragt werden. Dazu ist bei wind_create() das Fensterobjekt BACKDROP
hinzugekommen.


WIND_NEW
--------
wind_new() ist erst ab TOS 1.4 vorhanden und lîschte unter TOS bisher immer
rigoros alle anstehenden Update-Anforderungen und auch alle fremden Fenster
(von Accessories).
Mag!X fÅhrt wind_new() als aufwendige, globale und umfassende
AufrÑumfunktion fÅr eine Applikation aus und lîscht daher auch nur noch
deren Update-Anforderungen, Fenster, MenÅs usw usw.. Andere Applikationen
werden auf keinen Fall beeintrÑchtigt, die Funktion kann gefahrlos
aufgerufen werden (ist i.a. nicht nîtig, da Mag!X selbst nach Beenden einer
Applikation mit dem Schlimmsten rechnet und selbst wind_new() aufruft).


Alertboxen
----------
Wegen der KompatibilitÑt zu GEM/3 kînnen Alertboxen jetzt 40 Zeichen pro
Textzeile und 20 Zeichen pro Button enthalten. Au·erdem sind die Alertboxen
komplett tastaturbedienbar.


Erweiterte Funktionen bei der Eingabe
---------------------------------------
Die Eingabefelder bieten in Mag!X von Haus aus bereits viele Funktionen,
die sonst mÅhsam zu Fu· programmiert werden mÅssen. U.a. sind dies:

- exakte Cursorpositionierung per Maus
- TastaturkÅrzel, um den Cursor zum vorherigen/nÑchsten Wort oder zum
  Zeilenanfang/Zeilenende zu bewegen.
- EinfÅge/öberschreibmodus
- Lîschen bis Zeilenende
- Cut, Copy, Paste
- Eingabefelder mit kleiner Schrift funktionieren

Die Funktionen fÅr Help, Undo, Shift-hoch, Shift-runter und Ctrl-Q sind in
form_keybd() enthalten, die Cursorpositionierung per Maus in form_(x)do()
und objc_edit() und die restlichen Funktionen in objc_edit(). Wer in den
Genuû der entsprechenden Funktionen kommen mîchte, muû die dazu gehîrigen
AES-Aufrufe benutzen.

FÅr den Nachbau von Dialogen in Fenstern wurden folgende Erweiterungen
vorgenommen:

OBJC_EDIT
---------
Es gibt eine neue Unterfunktion von objc_edit() mit Modus 103, die wie
Modus 3 (ED_END) funktioniert und den Cursor im XOR- Modus zeichnet.
ZusÑtzlich muû jedoch in addrin[1] ein Zeiger auf ein GRECT Åbergeben
werden, auf das die Ausgabe beschrÑnkt wird; wichtig fÅr den Redraw im
Fenster.

FORM_KEYBD
----------
Wird form_keybd() mit objnr == 0x8765 aufgerufen, so werden Tasten
verarbeitet, die zusammen mit der ALT-Taste betÑtigt wurden. Der
RÅckgabewert ist 1, wenn ein passendes Objekt gefunden wurde; in diesem
Fall ist <key> gelîscht, und die Objektnummer steht in <nxtobj>.


Dialogroutinen
--------------
In  letzter  Zeit ist es immer mehr in Mode  gekommen,  statt  der
eingebauten  Behandlungsroutinen fÅr Dialogboxen eigene zu  verwenden,
die wesentlich komfortabler sind. Damit man nun das Rad nicht jedesmal
wieder  neu erfinden muû,  enthÑlt Mag!X neue  Dialogboxroutinen,  die
zusÑtzlich zur erhîhten FunktionalitÑt noch den Vorteil haben,  zu den
bisherigen Routinen abwÑrtskompatibel zu sein.  In der Praxis bedeutet
das, daû Sie Ihre alten Programme nur leicht zu modifizieren brauchen,
um die Vorteile von Mag!X zu nutzen. Noch mehr: Diese Programme laufen
nach wie  vor problemlos unter allen TOS- Versionen einschlieûlich MultiTOS.
Erreicht  wird  dies,indem  Mag!X  zusÑtzliche  Parameter Åbergeben
werden,  die  das  TOS einfach ignoriert.

  Zu    Beginn    eines   Dialogs   muû   man    den    entsprechenden
Bildschirmausschnitt reservieren. Dies geschieht i.a. mit der Funktion
form_dial()  und  der  Unterfunktion FMD_START.  Um  unter  Mag!X  die
fliegenden Dialoge zu nutzen,  muû hierbei der Hintergrund vollstÑndig
gerettet  werden.   Dazu  ruft  man  einfach  statt  form_dial()   die
erweiterte Funktion form_xdial() auf,  die als zusÑtzlichen  Parameter
<flydial> hat. Der Prototyp lautet:

   int  form_xdial( int flag, int ltx, int lty, int ltw, int lth,
                    int bgx, int bgy, int bgw, int bgh, void **flydial );

   Aufruf in Assembler:

   contrl[0] = 51      Opcode fÅr form_dial
   contrl[1] =  9      EintrÑge in intin
   contrl[2] =  1      EintrÑge in intout
   contrl[3] =  2      EintrÑge in addrin
   contrl[4] =  0      EintrÑge in addrout

   intin[0]  =  flag
   intin[1]  =  ltx
   intin[2]  =  lty
   intin[3]  =  ltw
   intin[4]  =  lth
   intin[5]  =  bgx
   intin[6]  =  bgy
   intin[7]  =  bgw
   intin[8]  =  bgh

   addrin[0] =  flydial
   addrin[1] =  0

   intout[0] =  (RÅckgabewert, 0 = Fehler)


  Wenn <flydial> ungleich 0 ist, prÅft Mag!X, ob genÅgend Speicher zur
VerfÅgung steht, um den Hintergrund unter der Dialogbox zu retten. Ein
Zeiger  auf  die  geretteten Daten wird dann  im  der  Variablen  ver-
merkt.  Wird  fÅr die Dialogboxbedienung die Funktion form_xdo()  ver-
wendet, ist die Box nun verschiebbar.
  Nach Beendigung des Dialogs wird form_xdial() mit der  Unterfunktion
FMD_FINISH  aufgerufen.  Auch hierbei wird die Variable <flydial>  mit
Åbergeben.  Mag!X  restauriert nun den Bildschirm und gibt den  Puffer
mit dem geretteten Hintergrund wieder frei.
  Steht  nicht  genÅgend  freier  Speicher  zur  VerfÅgung,   um   den
Hintergrund zu retten,  ist die Box nicht verschiebbar;  es wird  dann
auch keine abgeknickte Ecke angezeigt.
  Die erweiterte Dialogbehandlungsroutine hat den Prototyp:

   int  form_xdo( OBJECT *tree, int startob, int *lastcrsr,
                  XDO_INF *tabs, void *flydial );

   Aufruf in Assembler:

   contrl[0] = 50      Opcode fÅr form_do
   contrl[1] =  1      EintrÑge in intin
   contrl[2] =  2      EintrÑge in intout
   contrl[3] =  3      EintrÑge in addrin
   contrl[4] =  0      EintrÑge in addrout

   intin[0]  =  startob

   addrin[0] =  tree
   addrin[1] =  tabs
   addrin[2] =  flydial

   intout[0] =  (RÅckgabewert wie bei form_do)
   intout[1] =  lastcrsr


  Die  gerade  nicht  benîtigten zusÑtzlichen  Parameter  <tabs>  oder
<flydial> kînnen als Nullpointer Åbergeben werden.
  <flydial> ist dieselbe Variable,  die an form_xdial() Åbergeben  und
initialisiert wurde,  sie wird fÅr das Verschieben der Box  verwendet.
In <lastcrsr> erhÑlt man die Nummer desjenigen Objekts zurÅck,  in dem
sich der Cursor bei Beenden des Dialogs befand, den Wert kann man z.B.
einem nÑchsten form_(x)do() Åbergeben.  <tabs> ist ein Zeiger auf fol-
gende Struktur:

   typedef struct {
        SCANX *unsh;
        SCANX *shift;
        SCANX *ctrl;
        SCANX *alt;
        void  *resvd;
        } XDO_INF;

  In  dieser Struktur liegen Zeiger auf Tabellen,  die einem  Scancode
eine  Objektnummer  der  Dialogbox  zuordnen.   Hiermit  ist  es   auf
einfachste  Weise  mîglich,   Dialoge  vollstÑndig  Åber  Tastatur  zu
bedienen.  <unsh>  ist ein Zeiger fÅr Tasten ohne Shift,  <shift>  fÅr
Tasten mit Shift,  <ctrl> fÅr Kombinationen mit der Taste Control  und
<alt> fÅr Tasten,  die mit der Taste Alt betÑtigt wurden.  <resvd> muû
immer NULL sein! SCANX ist folgende Struktur:

   typedef struct {
        char scancode;
        char nclicks;
        int  objnr;
        } SCANX;

  Sie enthÑlt die Zuordnung fÅr die Taste mit dem Scancode <scancode>,
bei  deren  BetÑtigung  ein <nclicks>- facher  Klick  auf  das  Objekt
<objnr>  ausgefÅhrt wird.  Ein Scancode von Null markiert jeweils  das
Tabellenende.
Einfacher, aber weniger flexibel ist eine Tastaturbedienung Åber die
unterstrichenen Buttons zu erreichen (s.u.).
  Der  Einfachheit halber hier einmal ein  Beispielprogramm.  ZunÑchst
eine  Routine,  wie  sie  normalerweise  fÅr  die  Dialogboxbehandlung
verwendet wird:

   int do_dialog(OBJECT *dialog)
   {
        int cx, cy, cw, ch;
        int exitbutton;

        form_center(dialog, &cx, &cy, &cw, &ch);               /* Position */
        form_dial(FMD_START, 0,0,0,0, cx, cy, cw, ch);         /* Anfang */
        objc_draw(dialog, ROOT, MAX_DEPTH, cx, cy, cw, ch);    /* malen  */
        exitbutton = 0x7f & form_do(dialog, 0);                /* ausfÅhren */
        form_dial(FMD_FINISH, 0,0,0,0,cx, cy, cw, ch);         /* Ende */
        ob_dsel(dialog, exitbutton);
        return(exitbutton);
   }

  Wenn  Sie die Dialogbox verschieben mîchten,  genÅgen einige  wenige
Modifikationen.  Sie  mÅssen  dann nur noch die Datei MAGX.H  und  die
Bibliothek MAGXLIB.LIB verwenden.  Die erweiterte Funktion,  die unter
TOS natÅrlich problemlos funktioniert, sieht dann so aus:

   int do_dialog(OBJECT *dialog)
   {
        int cx, cy, cw, ch;
        int exitbutton;
        void *flyinf;
        void *scantab = NULL;         /* ggf. Tastencode- Tabelle */
        int  lastcrsr;                /* Cursorposition bei Dialogende */

        form_center( ... );
        form_xdial(FMD_START,  0,0,0,0, cx, cy, cw, ch, &flyinf);
        objc_draw( ... );
        exitbutton = 0x7f & form_xdo(dialog, 0, &lastcrsr, scantab, flyinf);
        form_xdial(FMD_FINISH, 0,0,0,0, cx, cy, cw, ch, &flyinf);
        ob_dsel( ... );
        return(exitbutton);
   }

Die Funktion form_center() funktioniert in Mag!X Åbrigens bei allen
Dialogtypen; egal mit welchem Rand oder Schatten.



Neue GEM- Funktionen im Mag!X-AES
---------------------------------

Mag!X enthÑlt eine Reihe von neuen Funktionen, die bereits in vielen
Anwenderprogrammen  existieren, jedoch mÅhsam immer wieder  neu
programmiert werden mÅssen. Auûerdem werden so die  Programme unnîtig lang,
was sich in einem Multitaskingsystem mit mehreren Programmen gleich
multipliziert. Alle Funktionen und Konstanten sind in  MAGX.H deklariert
und in MAGXLIB.LIB definiert, so daû Sie sich um die Einzelheiten nicht
mehr zu kÅmmern brauchen.
Ein hÑufig auftretendes  Bedienungselement ist ein MenÅ, das auûerhalb der
MenÅleiste und mitunter sogar an  Cursorposition erscheint, um schnell ohne
viele Mauswege eine Auswahl treffen zu kînnen. Mag!X stellt mit der neuen
Funktion form_popup() eine Lîsung dieses Problems bereit. Der Prototyp
lautet:

   int  form_popup     ( OBJECT *tree, int x, int y );

   Aufruf in Assembler:

   contrl[0] = 135     Opcode fÅr form_popup
   contrl[1] =  2      EintrÑge in intin
   contrl[2] =  1      EintrÑge in intout
   contrl[3] =  1      EintrÑge in addrin
   contrl[4] =  0      EintrÑge in addrout

   intin[0]  =  x
   intin[1]  =  y

   addrin[0] =  tree

   intout[0] =  Nummer des angewÑhlten Objekts oder -1


     x und y geben die Mausposition an,  um die die Box zentriert  werden
   soll,  man erhÑlt die Objektnummer des angeklicketen Objektes oder  -1
   zurÅck.  Sind x und y Null, wird die Position der Box nicht beeinfluût
   und muû vom Aufrufer gesetzt werden.  Das MenÅ sowie die Koordinaten x
   und y dÅrfen beliebige Werte annehmen,  Mag!X sorgt immer  dafÅr,  daû
   das MenÅ vollstÑndig auf dem Bildschirm liegt. Die Box tree sollte als
   Objekt  0  eine  G_BOX oder G_IBOX  enthalten,  die  von  den  anderen
   Objekten vollstÑndig bedeckt wird. Objekte, die nicht auswÑhlbar sind,
   sollten  wie  im Dropdown- MenÅ den  Status  DISABLED  erhalten.  Alle
   wÑhlbaren Objekte mÅssen den Status SELECTABLE haben.


Ein Groûteil der Programmierung besteht i.a. daraus, Fehleingaben des
Benutzers oder Fehler des des Systems zu erkennen und irgendwie sinnvoll zu
reagieren, dazu gehîrt insbesondere die Auswertung der vom System
erhaltenen Fehlermeldungen und öbersetzung der Codes in allgemein
verstÑndlichen Klartext. Die im AES enthaltene Funktion form_error()
existiert zwar fÅr diesen Zweck, bietet jedoch erstens zuwenig
differenzierte Fehlerbeschreibungen und ist zweitens nur fÅr MSDOS-
Fehlercodes ausgelegt. Um diesem Manko abzuhelfen, enthÑlt Mag!X die neue
Funktion form_xerr() mit folgendem Prototyp:

   int  form_xerr      ( long errcode, char *errfile );

   Aufruf in Assembler:

   contrl[0] = 136     Opcode fÅr form_xerr
   contrl[1] =  2      EintrÑge in intin
   contrl[2] =  1      EintrÑge in intout
   contrl[3] =  1      EintrÑge in addrin
   contrl[4] =  0      EintrÑge in addrout

   intin[0]  =  errcode (Hi)
   intin[1]  =  errcode (Lo)

   addrin[0] =  errfile

   intout[0] =  (RÅckgabewert wie bei form_err)


     errcode  ist ein normaler negativer GEMDOS- oder  BIOS-  Fehlercode,
   wie  er  von  diversen TOS- Funktionen  zurÅckgegeben  wird;  im  Fall
   errcode == EBREAK ("Programm wurde vom Benutzer per ^C beendet) oder
   errcode == E_OK ("kein Fehler") wird keine Alertbox  angezeigt.
   Im Parameter errfile kann man den Pfad einer Datei angeben, in der der
   Fehler  aufgetreten ist (etwa beim Beschreiben der  Datei).  Gibt  man
   einen Nullpointer an, wird der Parameter ignoriert, ein Zeiger mit dem
   Wert -1 fÅhrt dazu,  daû die Zeile "Programm gab zurÅck:" der  Meldung
   vorangestellt wird.



AES-Objekttypen
---------------

FÅr die bisherigen Standard-Objekttypen G_STRING, G_BUTTON und G_TITLE
kînnen jetzt Unterstriche festgelegt werden. Dies kann ganz einfach z.B.
mit INTERFACE durchgefÅhrt werden. ZusÑtzlich hat man zusÑtzliche Buttontypen,
nÑmlich runde und solche mit Kreuzchen, zur VerfÅgung.

Alle Modifikationen werden zunÑchst durch Setzen des Bits WHITEBAK von
ob_state aktiviert.

Bei den Objekttypen G_STRING und G_TITLE legt nun das High-Byte von ob_state
die Position des Unterstrichs fest. Ist das Hibyte = 255, wird das gesamte
Objekt unterstrichen, womit man leicht öberschriften erzeugen kann. Durch
Vergrîûern des Objekts Åber die TextlÑnge hinaus kann man die öberschrift
leicht verbreitern.

Aktiviert man bei einem G_BUTTON zusÑtzlich zum Statusbit WHITEBAK noch Bit
15 von ob_flags, wird ein Kreuzchen- Button angezeigt, falls es ein
normaler Button ist, oder ein runder Button, falls es ein RADIOBUTTON ist.
Dabei steht links vom Text steht ein KÑstchen, das bei Selektion ein
Kreuzchen enthÑlt, bzw. ein Kreis, der bei Selektion einen schwarzen
Inkreis enthÑlt.
Die Position des Unterstrichs steht im Hibyte von ob_state (ohne Bit 15, das
die Spezialbuttons aktiviert), ein Wert von -1 fÅr ob_state signalisiert,
daû nicht unterstrichen wird. Unterstrichene Objekte kînnen mit der Tastatur
Åber Alt-Buchstabe bedient werden.

StandardmÑûig sollten Buttons die Hîhe 1 Zeichen plus ein Pixel,
öberschriften 1 Zeichen und 2 Pixel haben, damit der Unterstrich erkennbar
ist.

Wird eine derartige RSC-Datei unter normalem TOS eingesetzt, ergeben sich
keinerlei Probleme, da die entsprechenden Bits komplett ignoriert werden.
Die neuen, unterstrichenen Objekttypen werden von den Dialogroutinen
ausgewertet, d.h. man muû sich um die Erkennung der Tastencodes fÅr diese
Typen keine Gedanken machen, das erledigt das System. Man beachte, daû nur
Buchstabentasten A..Z und Zahlen 0..9 des Haupttastenblocks verarbeitet
werden kînnen.
Ein Hauptaspekt an der vorliegenden Implementation der neuen, erweiterten
Objekttypen ist, daû sich hiermit alte Programme mit Hilfe eines Ressource-
Editors sehr einfach "aufpeppen" lassen, ohne auch nur einen einzigen
Eingriff in den Programmcode vornehmen zu mÅssen. Die Programme sind vîllig
ohne VerÑnderung unter jeder TOS- Version lauffÑhig, nur unter Mag!X
entfalten sie plîtzlich ihre versteckten FÑhigkeiten.

Der Window- Manager
-------------------

  Der Window- Manager von Mag!X arbeitet ein wenig anders als der  von
TOS. Jedes Mag!X- Fenster,  von denen es Åbrigens max. 63 gibt, hat in
in rechten oberen Ecke einen sogenannten Backdrop-Button. BetÑtigt man
diesen, wird das Fenster in den Hintergrund gelegt.
  Die neue Funktionsweise betrifft nicht nur das Aussehen der Fenster,
sondern auch das Zeichnen:
  Damit  fÅr den Benutzer der Bildschirmaufbau trotz  ausschlieûlicher
Benutzung dokumentierter Systemaufrufe so schnell ist,  wie es etwa in
MAGXDESK der Fall ist,  muû der Programmierer einiges beachten. Hat er
dies nicht getan, muû der Benutzer manchmal zum Hilfsprogramm MAGXCONF
greifen  und den "Smart Redraw" deaktivieren.  Damit dies  nicht  mehr
notwendig ist, hier eine Beschreibung dieser Eigenschaft:
  Mag!X verfolgt die Philosophie,  daû Geschwindigkeit nicht mit  bru-
talen Mitteln wie Grafikprozessoren usw. erreicht werden soll, sondern
mit ein wenig Nachdenken;  dazu gehîrt vor allem,  immer nur soviel zu
tun,  wie nîtig ist.  WÑhrend TOS beim Wechsel des aktuellen Fensters,
beim Schlieûen oder beim Verschieben mit Vorliebe das gesamte  Fenster
oder  gar  noch vîllig unschuldige,  unbeteiligte andere  Fenster  neu
zeichnet,  wird dies unter Mag!X wirkungsvoll vermieden.  Obwohl diese
unschîne Eigenschaft des TOS nirgendwo dokumentiert ist, nutzen leider
sehr  viele  Programme oder Bibliotheken (etwa die aus dem  Buch  "Vom
AnfÑnger  zum  GEM- Profi") aus,  daû das TOS  beim  Vergrîûern  eines
Fensters dieses immer neu zeichnet. Dazu ein Beispiel:
  Nehmen wir an, in ein Fenster passen fÅnf Spalten nebeneinander, die
auch  angezeigt  werden.  Wenn der Benutzer nun das  Fenster  so  weit
verkleinert,  daû  nur noch vier Spalten  hineinpassen,  sortiert  das
Programm  seine  Daten um und veranlaût anschlieûend  selbstÑndig  ein
Neuzeichnen  des Fensters (TOS zeichnet bei Verkleinerung das  Fenster
nicht von sich aus neu).  Vergrîûert der Benutzer dagegen das  Fenster
auf eine Breite von 7 Spalten, sortiert das Anwenderprogramm die Daten
ebenfalls  um,  veranlaût jedoch hier kein Neuzeichnen  des  Fensters.
Aufgrund des eher dummen Fehlverhalten des TOS, das Fenster fÅr diesen
Fall immer ganz neu zu zeichnen, findet dann die Ausgabe statt.
  Mag!X  zeichnet nun immer nur den minimal nîtigen Teil des  Fensters
neu,  das wÑren im Fall des Aufziehens eines Fensters hîchstens rechts
und unten zwei Rechtecke.  FÅr die Programme, die den oben beschriebe-
nen  Fehler des TOS ausnutzen,  gibt sich so eine Diskrepanz  zwischen
logischem und physikalischem Bildschirminhalt.  Viel einfacher wÑre es
gewesen,  einfach  auf  die Fallunterscheidung  "Fenster  grîûer  oder
kleiner  als vorher" zu verzichten und immer im Fall des  Umsortierens
einen  Redraw zu veranlassen.  Da das Betriebssystem auch im  TOS  die
Redraws zusammenfaût,  hat ein eventuell ÅberflÅssiger Redraw  niemals
irgendwelche Auswirkungen.
  Den  gleichen  Effekt  wie beschrieben hat man  Åbrigens  auch  beim
Vergrîûern  des Fensters,  wenn bereits die unterste  Zeile  bzw.  die
rechteste Zeile dargestellt wird. Auch hier ein Beispiel:
  Ein Text habe 100 Zeilen,  das Fenster habe eine Hîhe von 20 Zeilen.
Da der Scrollbalken ganz unten ist,  werden also die Zeilen 80 bis 100
im Fenster dargestellt. Wird nun das Fenster nach unten vergrîûert, so
daû  etwa  30 Zeilen Platz finden,  kînnte man  eigentlich  nur  einen
weiûen  Bereich aufziehen,  da unterhalb von Zeile 100 ja keine  Daten
mehr sind.  Um dies zu verhindern,  scrollen die meisten Programme  in
dieser  Situation ihre Daten,  in unserem Beispiel um 10  Zeilen  nach
oben.  Folglich zeigt das Programm jetzt die Zeilen 70 bis 100 an;  da
es  aber auf einem TOS- Fehler aufbaut,  wird kein Neuzeichnen  veran-
laût,  was unter Mag!X natÅrlich prompt zur Konfusion fÅhrt. Auch hier
wÑre  ein  generelles Neuzeichnen des Fensters beim  Umsortieren  auch
unter  TOS nicht nur sauber,  sondern auch ohne Nebenwirkung,  da  TOS
auch hier unnîtige Redraws vermeidet.
  Beim direkten Vergleich zwischen "Smart Redaw" und "TOS Redraw", was
hier durchaus im wîrtlichen Sinn als Gegenteil zu verstehen ist, zeigt
sich  in  ersterem  Fall ein  wesentlich  schnellerer,  ruhigerer  und
saubererer  Bildschirmaufbau,  der durchaus mit dem Macintosh-  System
konkurrieren kann und unter TOS selbst mit Blitter und 68040 Prozessor
in  dieser  Form nicht mîglich wÑre.  Daher wird  dringend  empfohlen,
diese  elegante Lîsung nicht durch Ausnutzen  undokumentierter  Eigen-
schaften des TOS zunichte zu machen.


Besonderheiten bei ACCs
-----------------------
  Accessories   gehîren   unter   GEM   zu   den   Stiefkindern    des
Betriebssystems.   Accessories  kînnen  keine  MenÅleiste  oder  einen
Desktop-  Hintergrund  besitzen  und  mÅssen  bei  jedem  Wechsel  der
Hauptapplikation ihre Fenster schlieûen,  allen Speicher freigeben und
alle  Dateien  schlieûen;  am besten ist es  sogar,  wenn  Accessories
Åberhaupt keine DOS- Aufrufe machen,  da unbeabsichtigte Beeinflussung
der  Hauptapplikation  nie ganz ausgeschlossen  ist.  Auf  jeden  Fall
kînnen Accesories keine weiteren Programme starten;  der entsprechende
Systemaufruf fÅhrt zum Absturz des TOS.
  Unter  Mag!X sind Accessories den  Programmen  gleichgestellt.  Ihre
Fenster  bleiben beim Programmwechsel erhalten.  Sie dÅrfen  MenÅ  und
Desktophintergrund  besitzen,  Programme  nachladen,  Dateien  îffnen,
schlieûen, lîschen, kopieren usw.
Da kein Grund mehr besteht, beim Programmwechsel Fenster zu schlieûen, gibt
es keine AC_CLOSE Meldung mehr. Accessories werden vom System nicht von
Programmen unterschieden, abgesehen davon, daû  sie sich keinesfalls
beenden dÅrfen.  ACCs dÅrfen sich wie unter GEM/2  auch  wieder im MenÅ
abmelden, und zwar mit dem AES-Aufruf menu_unregister().


GEM-Autostart-Applikationen
---------------------------
  Unter   Mag!X   gibt  es   verschiedene   Mîglichkeiten,   Programme
automatisch   zu   starten.   Beim   Start   von   Mag!X   oder   beim
Auflîsungswechsel  werden zunÑchst alle Accessories aus  ihrem  Ordner
geladen,  danach  die Programme mit der Endung .APP oder .PRG aus  dem
Programm- Autostart- Ordner. Beide Ordner werden in INSTMAGX angegeben
und  kînnen  gegebenenfalls mit einem  handelsÅblichen  Texteditor  in
MAGX.INF geÑndert werden;  die zugehîrige Zeile beginnt mit #_ACC bzw.
#_APP. Anschlieûend wird das ebenfalls in INSTMAGX angegebene Programm
gestartet,  die zugehîrige Zeile in MAGX.INF beginnt mit  #_AUT.  Erst
wenn  sich die unter #_AUT angemeldete Applikation beendet  hat,  wird
das   Desktop  MAGXDESK  geladen.   Dazu  wird  zunÑchst   im   Ordner
\GEMSYS\GEMDESK auf dem Bootlaufwerk gesucht,  dann im Wurzelverzeich-
nis.  Kann  MAGXDESK  nicht gefunden  werden,  wird  stattdessen  eine
Dateiauswahlbox angezeigt, mit Hilfe derer man Programme starten kann;
letzteres  kann  sinnvoll  sein,  wenn man Åber  sehr  wenig  Speicher
verfÅgt.
  Als Autostart- Programme kommen nur solche in Frage,  die nicht  den
gesamten Speicher beanspruchen;  notfalls muû man mit LIMITMEM  (s.u.)
etwas nachhelfen.
Unter Mag!X werden ACCs und Applikationen im GEM-Autostart-Ordner mit der
AES-Kommandozeile "\0\0AUTO\0" gestartet. Diese wird, da sie mit Nullbytes
beginnt, normalerweise nicht ausgewertet. Applikationen, die speziell fÅr
Mag!X entwickelt wurden, kînnen anhand dieser Kommandozeile beispielsweise
entscheiden, ob sie die MenÅleiste direkt anzeigen oder nur anmelden wollen
(siehe MENU_BAR) oder ob sie mit einer Dateiauswahlbox beginnen sollen oder
nicht.

GEMDOS
------
Mag!X enthÑlt ein Mehrprozeû-DOS, das zwar kompatibel zum bisherigen GEMDOS
ist, aber in entscheidenden Punkten (Filesystem, Speicherverwaltung) an die
Erfordernisse des Multitaskingbetriebs angepa·t wurde.
Au·erdem sind folgende Erweiterungen verfÅgbar:

Pfadauswertung
--------------
Behandelt TOS einen Pfad wie "\BIN\\x" wie eine Datei mit leerem Namen im
Ordner BIN, ignoriert Mag!X nun sÑmtliche ÅberflÅssigen '\' und erkennt in
diesem Fall eine Datei 'x' im Ordner "BIN". Auch "\\\\\BIN\\\\x" ist unter
Mag!X ein gÅltiger Pfad. Au·erdem kann man jetzt mit "..." usw. auf
Åbergeordnete Verzeichnisse direkt zugreifen. Bekannt ist dieses Feature
etwa unter MSDOS.

Speicherblock vergrî·ern
------------------------
  Unter  Mag!X kînnen Speicherblîcke mit Mshrink() vergrîûert  werden,
Åbergibt  man als Grîûe -1L,  so erhÑlt man die zum Zeitpunkt  maximal
mîgliche Grîûe.  Das Vergrîûern ist natÅrlich nur mîglich,  wenn  sich
ein freier Speicherblock darÅber befindet.

Fwrite
-------
  öbergibt  man Fwrite() 0 zu schreibende Bytes und einen -1L-  Zeiger
auf  die  zu  schreibenden Daten,  wird die  Datei  auf  die  aktuelle
Position des Dateizeigers geschrumpft.

Sconfig
-------
  Eine neue GEMDOS- Funktion Sconfig() manipuliert das Konfigurations-
Langwort,  das  auch  Åber  das  Mag!X-  Cookie  zugÑnglich  ist.  Der
Prototyp in C lautet "long Sconfig(int mode,  long bitset)" und ist in
MAGX.H definiert. Die Variable bitset hat folgende Bedeutung:

     Bit 0:    PfadÅberprÅfung ein
     Bit 1:    EinfÅgemodus fÅr GEMDOS und Dialogboxen
     Bit 2:    reserviert
     Bit 3:    reserviert
     Bit 4:    Fastload fÅr Diskette aus
     Bit 5:    TOS- KompatibilitÑt ein
     Bit 6:    "smart redraw" aus
     Bit 7:    Grow- und Shrinkboxen aus
     Bit 8:    kein Halt nach TOS- Programmen
     Bit 9:    reserviert
     Bit 10:   Pulldown- MenÅs

  Die  restlichen  Bits  sind reserviert und  dÅrfen  nicht  verÑndert
werden.  Mit  mode  =  0  werden  die  Bits  gelesen,  mit  mode  =  1
geschrieben (geht nur bei deaktivierter KompatibilitÑt),  mit mode = 2
erhÑlt  man  einen  Zeiger auf die DOSVARS  Struktur,  die  in  MAGX.H
definiert ist:

typedef struct
   {
   char      *in_dos;                 /* Adresse der DOS- Semaphore */
   int       *dos_time;               /* Adresse der DOS- Zeit      */
   int       *dos_date;               /* Adresse des DOS- Datums    */
   long      res1;                    /*                            */
   long      res2;                    /*                            */
   long      res3;                    /* ist 0L                     */
   void      *act_pd;                 /* Laufendes Programm         */
   long      res4;                    /*                            */
   int       res5;                    /*                            */
   void      res6;                    /*                            */
   void      res7;                    /* interne DOS- Speicherliste */
   void      (*resv_intmem)();        /* DOS- Speicher erweitern    */
   long      (*etv_critic)();         /* etv_critic des GEMDOS      */
   char *    ((*err_to_str)(char e)); /* Umrechnung Code->Klartext  */
   long      res8;                    /*                            */
   long      res9;                    /*                            */
   } DOSVARS;

  Mit  Hilfe  der  Funktion resv_intmem() lÑût sich  Ñhnlich  wie  mit
FOLDRnnn Speicher fÅr die interne Speicherverwaltung  reservieren.  Im
Gegensatz zu TOS wird diese jedoch deutlich weniger belastet,  so  daû
ein  Erweitern i.a.  nicht notwendig ist.  Muû der Speicher  erweitert
werden,  was  auch  in ADDMEM geschieht,  Åbergibt  man  der  Funktion
resv_intmem()  in  a0  die  Adresse  und  in  d0  die  LÑnge  des   zu
reservierenden Speicherblocks.
  Der   Prototyp   fÅr  den  Event-  Critic-  Handler   lautet   "long
etv_critic(int errcode, int drvnr)". Man beachte, daû die Funktion die
Argumente  auf  dem Stapel erwartet und daher in Turbo C  als  "cdecl"
deklariert werden muû.
  err_to_str() erwartet in d0 einen TOS- Fehlercode und gibt in d0 und
a0 einen Zeiger auf die beschreibende Zeichenkette zurÅck.  Bei  einem
ungÅltigen  Fehlercode  erhÑlt  man in d0 eine Null und  in  a0  einen
Zeiger auf die Zeichenkette "TOS Fehler".

GEMDOS Eingaberoutine
---------------------
  TOS-Programme wie der Shareware-Kommandointerpreter  MCMD, die keine
eigenen Eingaberoutinen verwenden, profitieren von der neuen GEMDOS-
Eingaberoutine, die folgende Editiertasten verarbeitet:

  Cursor links/rechts    Cursor ein Zeichen bewegen
  Shift- Cursor l/r      Cursor an Zeilenanfang/-ende
  Shift- Cursor links    Cursor auf den Anfang des Eingabefeldes
  Home                   wie Shift- Cursor links
  Shift- Clr             Eingabe lîschen
  Tab                    wechselseitig Zeilenanfang/-ende
  Cursor hoch/runter     letzte Eingabe(n) zurÅckholen
  Undo                   letzte Eingabe
  Del/Backspace          Zeichen unter/vor Cursor lîschen
  Insert                 EinfÅgemodus
  Shift- Insert          öberschreibmodus
  F1..F10                Environmentvariablen F1..F0 abrufen

  Die  Environment-Variablen kînnen mit jedem beliebigen
  Kommandointerpreter belegt werden, i.a. mit einem SET- Kommando.

Beachten Sie bitte, da· das Mag!X-GEMDOS (mit Ausnahme des Dateisystem - s.
Hinweis) reentrant arbeitet. Sichtbar ist dies z.B. daran, daû Altertboxen
des Types "Daten auf Disk A: defekt" verschiebbar sind - hierzu muû nÑmlich
Speicher angefordert werden, was unter TOS nicht funktioniert, da gerade
eine Dateioperation im GEMDOS abgearbeitet wird.

Hinweis: Im Hinblick auf zukÅnftige Mag!X-Versionen sollten Sie den Einsatz
         der GEMDOS Super()-Funktion vermeiden. Diese Funktion verursacht
         im Zusammenhang mit virtuellem Speicher und unterbrechbaren (und
         reentranten) Dateisystemen in einem Multitaskingsystem gro·e
         Probleme. Stellen Sie ggf. Ihren Code so um, da· Sie die
         BIOS-Funktion Supexec() verwenden kînnen.


etv_term
--------
Programme, die sich in irgendwelche Systemvektoren hÑngen, solten sich auch
in den etv_term-Vektor einklinken. Falls das Programm nun abnormal beendet
wird, sei es durch den Programm-Manager, durch ein anderes amoklaufendes
Programm oder gar durch einen Programmierfehler, springt das System
zunÑchst Åber den etv_term-Vektor. Bei dieser Gelegenheit kînnen Sie sich
dann in Ruhe aus allen Vektoren zurÅckziehen. Da Mag!X fÅr jede Applikation
einen eigenen etv_term-Vektor verwendet, kann es dabei nicht zu Kollisionen
kommen.
Da sich die Struktur des Prozeûdeskriptors ("Basepage") in den nicht
dokumentierten Bereichen geÑndert hat, ist unbedingt darauf zu achten,
nur die dokumentierten Strukturelemente zu verwenden.


(X)BIOS
-------

BIOS und XBIOS sind in Mag!X reentrant. D.h. diese Funktionen kînnen
(solange der jeweilge Supervisorstack nicht ÅberlÑuft...) auch aus
Interrupts mehrfach aufgerufen werden.

Hinweis:
- Die <saveptr_area> des BIOS ist (aus KompatiblitÑtsgrÅnden) noch
   vorhanden, wird jedoch vom System nicht benutzt.
- Die StackÅberprÅfung von Turbo C/Pure C wird bei Routinen versagen, die
   im Supervisormodus ausgefÅhrt werden (unter TOS konnte das bisher nur
   bei USERDEF-Routinen im AES, die ebenfalls im Supervisormdus ausgefÅhrt
   werden, passieren).

Falls Sie eigene Routinen ins (X)BIOS hÑngen, dann achten Sie darauf, diese
voll reentrant zu gestalten. Machen Sie keine Annahmen Åber den Inhalt der
<saveptr_area>!

Modems, Schnittstellenbeschleuniger, Interruptroutinen
---------------------------------------------------------
Mag!X 2.0 enthÑlt hochoptimierte Interruptroutinen, die es gestatten, auch
mit einem 8 MHz ST im Multitaskingbetrieb HochgeschwindigkeitsÅbertragungen
auf der seriellen Schnittstelle durchzufÅhren. Die bei vielen TOS-Versionen
benîtigten Fix-Programme (RS232ENC, SERFIX,...) sollten Sie unter Mag!X
nicht einsetzen - sie bremsen bestenfalls das System (Ausnahme: HSMODEM; s.
nÑchster Abschnitt).

Wenn Sie wÑhrend einer öbertragung gleichzeitig mit einem Editor arbeiten
(z.B. Pure C-Editor) ist auf einem 8 MHz ST ein sicherer Betrieb mit
maximal 38400 Baud mîglich. 57600 Baud erfordern einen 68000er mit 16 MHz
(oder Sie dÅrfen wÑhrend der öbertragung nicht tippen...).

Schnittstellenbeschleuniger
---------------------------
Wie Sie sicherlich wissen, kann Ihr ST von Haus aus die serielle
Schnittstelle nur mit 19200 Baud ansteuern - fÅr clevere TÅftler war das
natÅrlich mehr eine Herausforderung als ein Hindernis.
Eine empfehlenswerte und leicht zu installierende Lîsung (vier Kabel) ist
RSVE von Harun Scheutzow. Sie stellt auf dem ST die Datenraten 38400, 57600
und 115200 Baud zur VerfÅgung. Mit der beiliegende Software (HSMODEM; die
Modem 1-Routinen von Mag!X basieren auf den dankenswerterweise von Harun
Scheutzow zur VerfÅgung gestellten Routinen) sind durch Block-I/O zusammen
mit einer angepa·ten ZMODEM-Version weitere Steigerungen der
öbertragungsrate mîglich.

P.S. (fÅr Geschwindigkeitsfetischisten):
Ein TT erreicht bei direkter Rechnerkopplung mit Mag!X und der
Terminalsoftware CoNnect 2.4x (Modem 2-Schnittstelle mit 153000 Baud und internem
ZModem) eine öbertragungsrate von ca. 15000 cps.

Was sollten Sie im Hinblick auf zukÅnftige Mag!X-Versionen beachten?
--------------------------------------------------------------------

1. BerÅcksichtigen Sie, da· MiNT-kompatible Funktionen vorhanden sein
   kînnen. Das Vorhandensein einer GEMDOS-Funktion kînnen Sie durch Aufruf
   der Funktion (z.B. Dlock) prÅfen; im Fehlerfall liefert GEMDOS <EINVFN>
   zurÅck.

2. Testen Sie ob Pipes vorhanden sind. In diesem Fall kînnen Sie das von
   ATARI neu definierte Drag & Drop-Protokoll direkt verwenden.
   Dazu notwendige Schritte sind:
   - Ist Laufwerk U vorhanden?
   - Ist Fxattr() vorhanden?
   - Wenn ja, liefert es Typ PIPE zurÅck? ...

3. Verwenden Sie wann immer mîglich die Xbios-Funktion Supexec() anstelle
   der GEMDOS-Funktion Super(). Verwenden Sie beide Funktionen nur Ñu·erst
   sparsam (in beiden FÑllen wird der Taskswitch unterbunden).

4. Im Hinblick auf zukÅnftige Mag!X-Versionen sollten Sie (z.B. beim
   VA-Protokoll) darauf achten, daû zur Kommunikation zwischen
   verschiedenen Programmen benutzte oder Åber Zeiger zugewiesene
   Speicherbereiche global sein mÅssen (also Åber die erweiterte
   Mxalloc()-Funktion mit GLOBAL-Flag alloziert werden - siehe dazu
   auch MiNT bzw. MultiTOS-Dokumentation).
   Andernfalls wird es beim Einsatz auf Rechnern mit PMMU (TT, Falcon
   oder sonstiger Rechner mit 68030) zu Speicherschutzverletzungen
   kommen.

